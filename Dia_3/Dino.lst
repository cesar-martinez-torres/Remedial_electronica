CCS PCM C Compiler, Version 5.076, 41008               10-jun.-21 16:29

               Filename:   D:\Users\20808\Documents\Repositorios\Remedial_electronica\Dia_3\Dino.lst

               ROM used:   3156 words (39%)
                           Largest free fragment is 2048
               RAM used:   87 (17%) at main() level
                           123 (24%) worst case
               Stack used: 5 locations
               Stack size: 16

*
0000:  MOVLP  00
0001:  GOTO   34C
0002:  NOP
.................... #include <16f1937.h>            //pic a utilizar           
.................... //////////// Standard Header file for the PIC16F1937 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1937 
0003:  DATA 0C,00
0004:  DATA D0,32
0005:  DATA 72,32
0006:  DATA E9,39
0007:  DATA F4,32
0008:  DATA 00,01
0009:  DATA CE,32
000A:  DATA 77,10
000B:  DATA D2,32
000C:  DATA E3,37
000D:  DATA 72,32
000E:  DATA 21,1D
000F:  DATA A5,19
0010:  DATA CC,3A
0011:  DATA 25,26
0012:  DATA 75,00
0013:  DATA 0C,00
0014:  DATA D0,3A
0015:  DATA 6E,3A
0016:  DATA F5,30
0017:  DATA E3,34
0018:  DATA 6F,37
0019:  DATA BA,12
001A:  DATA 33,26
001B:  DATA F5,12
001C:  DATA CC,3A
001D:  DATA 00,01
001E:  DATA 0C,00
001F:  DATA 0C,00
0020:  DATA 0C,00
0021:  DATA 50,39
0022:  DATA E5,39
0023:  DATA E9,37
0024:  DATA EE,30
0025:  DATA A0,20
0026:  DATA 00,01
0027:  DATA D0,30
0028:  DATA F2,30
0029:  DATA A0,31
002A:  DATA EF,36
002B:  DATA 65,37
002C:  DATA FA,30
002D:  DATA 72,00
002E:  DATA 0C,00
002F:  DATA 50,39
0030:  DATA E5,39
0031:  DATA 65,37
0032:  DATA F4,30
0033:  DATA E4,37
0034:  DATA 20,38
0035:  DATA 6F,39
0036:  DATA 3A,00
0037:  DATA CA,32
0038:  DATA F3,3A
0039:  DATA 73,10
003A:  DATA C6,32
003B:  DATA 72,10
003C:  DATA C8,34
003D:  DATA F2,30
003E:  DATA 6D,00
003F:  DATA 0C,00
0040:  RETLW  C2
0041:  RETLW  A1
0042:  RETLW  20
0043:  RETLW  4C
0044:  RETLW  49
0045:  RETLW  53
0046:  RETLW  54
0047:  RETLW  4F
0048:  RETLW  20
0049:  RETLW  21
004A:  RETLW  00
004B:  DATA 0C,00
004C:  DATA 0C,00
004D:  DATA 0C,00
004E:  DATA 0C,00
004F:  DATA 0C,00
*
0200:  MOVF   0B,W
0201:  BCF    0B.7
0202:  MOVLB  03
0203:  BSF    15.7
0204:  BSF    15.0
0205:  NOP
0206:  NOP
0207:  BTFSC  09.7
0208:  BSF    0B.7
0209:  MOVF   13,W
020A:  ANDLW  7F
020B:  BTFSC  03.2
020C:  GOTO   24C
020D:  MOVLB  01
020E:  MOVWF  25
020F:  MOVLB  03
0210:  MOVF   11,W
0211:  MOVLB  01
0212:  MOVWF  26
0213:  MOVLB  03
0214:  MOVF   12,W
0215:  MOVLB  01
0216:  MOVWF  27
0217:  MOVF   25,W
0218:  MOVWF  31
0219:  MOVLB  00
021A:  CALL   1C6
021B:  MOVLB  01
021C:  MOVF   26,W
021D:  MOVLB  03
021E:  MOVWF  11
021F:  MOVLB  01
0220:  MOVF   27,W
0221:  MOVLB  03
0222:  MOVWF  12
0223:  MOVF   0B,W
0224:  BCF    0B.7
0225:  BSF    15.7
0226:  BSF    15.0
0227:  NOP
0228:  NOP
0229:  BTFSC  09.7
022A:  BSF    0B.7
022B:  RLF    13,W
022C:  RLF    14,W
022D:  ANDLW  7F
022E:  BTFSC  03.2
022F:  GOTO   24C
0230:  MOVLB  01
0231:  MOVWF  25
0232:  MOVLB  03
0233:  MOVF   11,W
0234:  MOVLB  01
0235:  MOVWF  26
0236:  MOVLB  03
0237:  MOVF   12,W
0238:  MOVLB  01
0239:  MOVWF  27
023A:  MOVF   25,W
023B:  MOVWF  31
023C:  MOVLB  00
023D:  CALL   1C6
023E:  MOVLB  01
023F:  MOVF   26,W
0240:  MOVLB  03
0241:  MOVWF  11
0242:  MOVLB  01
0243:  MOVF   27,W
0244:  MOVLB  03
0245:  MOVWF  12
0246:  INCF   11,F
0247:  BTFSC  03.2
0248:  INCF   12,F
0249:  MOVLB  00
024A:  GOTO   200
024B:  MOVLB  03
024C:  MOVLB  00
024D:  RETURN
024E:  MOVF   00,F
024F:  BTFSC  03.2
0250:  GOTO   262
0251:  MOVF   05,W
0252:  MOVLB  01
0253:  MOVWF  23
0254:  MOVF   04,W
0255:  MOVWF  22
0256:  MOVF   00,W
0257:  MOVWF  31
0258:  MOVLB  00
0259:  CALL   1C6
025A:  MOVLB  01
025B:  MOVF   23,W
025C:  MOVWF  05
025D:  MOVF   22,W
025E:  MOVWF  04
025F:  ADDFSR 01,FSR0
0260:  MOVLB  00
0261:  GOTO   24E
0262:  MOVLP  00
0263:  GOTO   479 (RETURN)
0264:  MOVF   0B,W
0265:  BCF    0B.7
0266:  MOVLB  03
0267:  BSF    15.7
0268:  BSF    15.0
0269:  NOP
026A:  NOP
026B:  BTFSC  09.7
026C:  BSF    0B.7
026D:  BTFSC  03.0
026E:  GOTO   297
026F:  MOVF   13,W
0270:  ANDLW  7F
0271:  MOVLB  01
0272:  MOVWF  25
0273:  MOVLB  03
0274:  MOVF   11,W
0275:  MOVLB  01
0276:  MOVWF  26
0277:  MOVLB  03
0278:  MOVF   12,W
0279:  MOVLB  01
027A:  MOVWF  27
027B:  MOVF   25,W
027C:  MOVWF  31
027D:  MOVLB  00
027E:  CALL   1C6
027F:  MOVLB  01
0280:  MOVF   26,W
0281:  MOVLB  03
0282:  MOVWF  11
0283:  MOVLB  01
0284:  MOVF   27,W
0285:  MOVLB  03
0286:  MOVWF  12
0287:  MOVF   0B,W
0288:  BCF    0B.7
0289:  BSF    15.7
028A:  BSF    15.0
028B:  NOP
028C:  NOP
028D:  BTFSC  09.7
028E:  BSF    0B.7
028F:  MOVLB  01
0290:  DECFSZ 24,F
0291:  GOTO   293
0292:  GOTO   295
0293:  MOVLB  03
0294:  GOTO   297
0295:  GOTO   2BA
0296:  MOVLB  03
0297:  RLF    13,W
0298:  RLF    14,W
0299:  ANDLW  7F
029A:  MOVLB  01
029B:  MOVWF  25
029C:  MOVLB  03
029D:  MOVF   11,W
029E:  MOVLB  01
029F:  MOVWF  26
02A0:  MOVLB  03
02A1:  MOVF   12,W
02A2:  MOVLB  01
02A3:  MOVWF  27
02A4:  MOVF   25,W
02A5:  MOVWF  31
02A6:  MOVLB  00
02A7:  CALL   1C6
02A8:  MOVLB  01
02A9:  MOVF   26,W
02AA:  MOVLB  03
02AB:  MOVWF  11
02AC:  MOVLB  01
02AD:  MOVF   27,W
02AE:  MOVLB  03
02AF:  MOVWF  12
02B0:  INCF   11,F
02B1:  BTFSC  03.2
02B2:  INCF   12,F
02B3:  BCF    03.0
02B4:  MOVLB  01
02B5:  DECFSZ 24,F
02B6:  GOTO   2B8
02B7:  GOTO   2BA
02B8:  MOVLB  00
02B9:  GOTO   264
02BA:  MOVLB  00
02BB:  RETURN
02BC:  MOVF   05,W
02BD:  MOVLB  01
02BE:  MOVWF  30
02BF:  MOVF   04,W
02C0:  MOVWF  2F
02C1:  SWAPF  25,W
02C2:  IORLW  F0
02C3:  MOVWF  2B
02C4:  ADDWF  2B,F
02C5:  ADDLW  E2
02C6:  MOVWF  2C
02C7:  ADDLW  32
02C8:  MOVWF  2E
02C9:  MOVF   25,W
02CA:  ANDLW  0F
02CB:  ADDWF  2C,F
02CC:  ADDWF  2C,F
02CD:  ADDWF  2E,F
02CE:  ADDLW  E9
02CF:  MOVWF  2D
02D0:  ADDWF  2D,F
02D1:  ADDWF  2D,F
02D2:  SWAPF  24,W
02D3:  ANDLW  0F
02D4:  ADDWF  2D,F
02D5:  ADDWF  2E,F
02D6:  RLF    2D,F
02D7:  RLF    2E,F
02D8:  COMF   2E,F
02D9:  RLF    2E,F
02DA:  MOVF   24,W
02DB:  ANDLW  0F
02DC:  ADDWF  2E,F
02DD:  RLF    2B,F
02DE:  MOVLW  07
02DF:  MOVWF  2A
02E0:  MOVLW  0A
02E1:  ADDWF  2E,F
02E2:  DECF   2D,F
02E3:  BTFSS  03.0
02E4:  GOTO   2E1
02E5:  ADDWF  2D,F
02E6:  DECF   2C,F
02E7:  BTFSS  03.0
02E8:  GOTO   2E5
02E9:  ADDWF  2C,F
02EA:  DECF   2B,F
02EB:  BTFSS  03.0
02EC:  GOTO   2E9
02ED:  ADDWF  2B,F
02EE:  DECF   2A,F
02EF:  BTFSS  03.0
02F0:  GOTO   2ED
02F1:  MOVLW  20
02F2:  MOVWF  05
02F3:  MOVLW  5A
02F4:  MOVWF  04
02F5:  MOVLW  07
02F6:  ANDWF  2F,W
02F7:  BCF    2F.6
02F8:  ADDWF  04,F
02F9:  MOVLW  00
02FA:  ADDWFC 05,F
02FB:  MOVF   04,W
02FC:  SUBLW  5E
02FD:  BTFSS  03.2
02FE:  GOTO   303
02FF:  MOVF   05,W
0300:  SUBLW  20
0301:  BTFSC  03.2
0302:  BSF    2F.6
0303:  MOVF   00,W
0304:  MOVWF  77
0305:  BTFSS  03.2
0306:  GOTO   30F
0307:  BTFSC  2F.6
0308:  GOTO   30F
0309:  BTFSC  2F.4
030A:  GOTO   320
030B:  BTFSC  2F.3
030C:  GOTO   30F
030D:  MOVLW  20
030E:  GOTO   312
030F:  BSF    2F.3
0310:  BCF    2F.4
0311:  MOVLW  30
0312:  ADDWF  77,F
0313:  MOVF   05,W
0314:  MOVWF  25
0315:  MOVF   04,W
0316:  MOVWF  24
0317:  MOVF   77,W
0318:  MOVWF  31
0319:  MOVLB  00
031A:  CALL   1C6
031B:  MOVLB  01
031C:  MOVF   25,W
031D:  MOVWF  05
031E:  MOVF   24,W
031F:  MOVWF  04
0320:  ADDFSR 01,FSR0
0321:  BTFSS  2F.6
0322:  GOTO   2FB
0323:  MOVLB  00
0324:  RETURN
0325:  CLRF   78
0326:  CLRF   79
0327:  CLRF   77
0328:  CLRF   7A
0329:  MOVLB  01
032A:  MOVF   2A,W
032B:  BTFSS  03.2
032C:  GOTO   330
032D:  MOVF   29,W
032E:  BTFSC  03.2
032F:  GOTO   34A
0330:  MOVLW  10
0331:  MOVWF  2B
0332:  BCF    03.0
0333:  RLF    27,F
0334:  RLF    28,F
0335:  RLF    77,F
0336:  RLF    7A,F
0337:  MOVF   2A,W
0338:  SUBWF  7A,W
0339:  BTFSS  03.2
033A:  GOTO   33D
033B:  MOVF   29,W
033C:  SUBWF  77,W
033D:  BTFSS  03.0
033E:  GOTO   346
033F:  MOVF   29,W
0340:  SUBWF  77,F
0341:  BTFSS  03.0
0342:  DECF   7A,F
0343:  MOVF   2A,W
0344:  SUBWF  7A,F
0345:  BSF    03.0
0346:  RLF    78,F
0347:  RLF    79,F
0348:  DECFSZ 2B,F
0349:  GOTO   332
034A:  MOVLB  00
034B:  RETURN
*
09C7:  MOVLW  20
09C8:  MOVWF  33
09C9:  CLRF   2F
09CA:  CLRF   30
09CB:  CLRF   31
09CC:  CLRF   32
09CD:  MOVF   27,W
09CE:  MOVWF  7A
09CF:  MOVF   26,W
09D0:  MOVWF  79
09D1:  MOVF   25,W
09D2:  MOVWF  78
09D3:  MOVF   24,W
09D4:  MOVWF  77
09D5:  BCF    03.0
09D6:  BTFSS  77.0
09D7:  GOTO   1E6
09D8:  MOVF   28,W
09D9:  ADDWF  2F,F
09DA:  MOVF   29,W
09DB:  BTFSC  03.0
09DC:  INCFSZ 29,W
09DD:  ADDWF  30,F
09DE:  MOVF   2A,W
09DF:  BTFSC  03.0
09E0:  INCFSZ 2A,W
09E1:  ADDWF  31,F
09E2:  MOVF   2B,W
09E3:  BTFSC  03.0
09E4:  INCFSZ 2B,W
09E5:  ADDWF  32,F
09E6:  RRF    32,F
09E7:  RRF    31,F
09E8:  RRF    30,F
09E9:  RRF    2F,F
09EA:  RRF    7A,F
09EB:  RRF    79,F
09EC:  RRF    78,F
09ED:  RRF    77,F
09EE:  DECFSZ 33,F
09EF:  GOTO   1D5
....................  
.................... #list 
....................  
.................... //#include <time.h> 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
09B0:  MOVF   25,W
09B1:  MOVLB  01
09B2:  MOVWF  27
09B3:  MOVLB  00
09B4:  MOVF   24,W
09B5:  MOVLB  01
09B6:  MOVWF  26
09B7:  MOVLB  00
09B8:  MOVF   23,W
09B9:  MOVLB  01
09BA:  MOVWF  25
09BB:  MOVLB  00
09BC:  MOVF   22,W
09BD:  MOVLB  01
09BE:  MOVWF  24
09BF:  MOVLW  41
09C0:  MOVWF  2B
09C1:  MOVLW  C6
09C2:  MOVWF  2A
09C3:  MOVLW  4E
09C4:  MOVWF  29
09C5:  MOVLW  6D
09C6:  MOVWF  28
*
09F0:  MOVF   7A,W
09F1:  MOVWF  27
09F2:  MOVF   79,W
09F3:  MOVWF  26
09F4:  MOVF   78,W
09F5:  MOVWF  25
09F6:  MOVF   77,W
09F7:  MOVWF  24
09F8:  MOVLW  39
09F9:  ADDWF  24,W
09FA:  MOVLB  00
09FB:  MOVWF  22
09FC:  MOVLW  30
09FD:  MOVLB  01
09FE:  ADDWFC 25,W
09FF:  MOVLB  00
0A00:  MOVWF  23
0A01:  MOVLW  00
0A02:  MOVLB  01
0A03:  ADDWFC 26,W
0A04:  MOVLB  00
0A05:  MOVWF  24
0A06:  MOVLW  00
0A07:  MOVLB  01
0A08:  ADDWFC 27,W
0A09:  MOVLB  00
0A0A:  MOVWF  25
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0A0B:  MOVF   24,W
0A0C:  MOVWF  77
0A0D:  MOVF   25,W
0A0E:  MOVWF  78
0A0F:  CLRF   79
0A10:  CLRF   7A
0A11:  MOVF   25,W
0A12:  MOVLB  01
0A13:  MOVWF  26
0A14:  MOVF   77,W
0A15:  MOVWF  25
0A16:  MOVF   26,W
0A17:  MOVWF  28
0A18:  MOVF   25,W
0A19:  MOVWF  27
0A1A:  MOVLW  7F
0A1B:  MOVWF  2A
0A1C:  MOVLW  FF
0A1D:  MOVWF  29
0A1E:  MOVLP  00
0A1F:  MOVLB  00
0A20:  CALL   325
0A21:  MOVLP  08
0A22:  MOVF   77,W
0A23:  MOVWF  78
0A24:  MOVF   7A,W
0A25:  MOVWF  79
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <tones.c> 
.................... ////////////////// Driver to generate musical tones ///////////////////// 
.................... ////                                                                 //// 
.................... ////  generate_tone(frequency, duration)     Generates wave at set   //// 
.................... ////                                         frequency (Hz) for set  //// 
.................... ////                                         duration (ms)           //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef  MUSIC_NOTES 
.................... #define  MUSIC_NOTES 
....................  
.................... //            NOTE                 FREQUENCY 
.................... //                     Octave0  Octave1  Octave2  Octave3 
.................... const long C_NOTE[4]  ={ 262,     523,    1047,    2093}; 
.................... const long Db_NOTE[4] ={ 277,     554,    1109,    2217}; 
.................... const long D_NOTE[4]  ={ 294,     587,    1175,    2349}; 
.................... const long Eb_NOTE[4] ={ 311,     622,    1245,    2489}; 
.................... const long E_NOTE[4]  ={ 330,     659,    1329,    2637}; 
.................... const long F_NOTE[4]  ={ 349,     698,    1397,    2794}; 
.................... const long Gb_NOTE[4] ={ 370,     740,    1480,    2960}; 
.................... const long G_NOTE[4]  ={ 392,     784,    1568,    3136}; 
.................... const long Ab_NOTE[4] ={ 415,     831,    1661,    3322}; 
.................... const long A_NOTE[4]  ={ 440,     880,    1760,    3520}; 
.................... const long Bb_NOTE[4] ={ 466,     923,    1865,    3729}; 
.................... const long B_NOTE[4]  ={ 494,     988,    1976,    3951}; 
.................... #endif 
....................  
.................... #define TONE_PIN  PIN_B0 
....................  
....................  
.................... void do_delay(int ms_delay, int num_ms, int us_delay, int num_us)  { 
....................  int i; 
....................  
....................  for(i=0;i<num_ms;i++) 
....................   delay_ms(250); 
....................  delay_ms(ms_delay); 
....................  for(i=0;i<num_us;i++) 
....................   delay_us(250); 
....................  delay_us(us_delay); 
.................... } 
....................  
....................  
.................... void generate_tone(long frequency, long duration) 
.................... { 
....................    int32 total_delay_time;                      // in microseconds 
....................    long total_ms_delay_time, total_us_delay_time; 
....................    int num_us_delays, num_ms_delays, ms_delay_time, us_delay_time; 
....................    long num_periods; 
....................  
....................    total_delay_time = (1000000/frequency)/2-10; // calculate total delay time (10 for error) 
....................  
....................    total_ms_delay_time = total_delay_time/1000; // total delay time of ms 
....................    num_ms_delays = total_ms_delay_time/250;     // number of 250ms delays needed 
....................    ms_delay_time = total_ms_delay_time%250;     // left over ms delay time needed 
....................  
....................    total_us_delay_time = total_delay_time%1000; // total delay time of us (ms already acounted for) 
....................    num_us_delays = total_us_delay_time/250;     // number of 250us delays needed 
....................    us_delay_time = total_us_delay_time%250;     // left over us delay time needed 
....................  
....................    num_periods = ((int32)duration*1000)/(1000000/frequency); 
....................  
....................    while((num_periods--) != 0) 
....................    { 
....................       do_delay(ms_delay_time, num_ms_delays, us_delay_time, num_us_delays); 
....................       output_high(TONE_PIN); 
....................       do_delay(ms_delay_time, num_ms_delays, us_delay_time, num_us_delays); 
....................       output_low(TONE_PIN); 
....................    } 
....................  
....................    return; 
.................... } 
....................  
.................... #use standard_io (D) 
.................... #use standard_io (B) 
.................... #fuses XT, NOPROTECT, NOWRT, NOPUT, NOWDT, NOLVP, NOCPD       //ordenes para el programador  
.................... #use delay (clock=4000000)         //Fosc=4Mhz 
*
0050:  MOVLW  20
0051:  MOVWF  05
0052:  MOVLW  62
0053:  MOVWF  04
0054:  MOVF   00,W
0055:  BTFSC  03.2
0056:  GOTO   065
0057:  MOVLW  01
0058:  MOVWF  78
0059:  CLRF   77
005A:  DECFSZ 77,F
005B:  GOTO   05A
005C:  DECFSZ 78,F
005D:  GOTO   059
005E:  MOVLW  4A
005F:  MOVWF  77
0060:  DECFSZ 77,F
0061:  GOTO   060
0062:  GOTO   063
0063:  DECFSZ 00,F
0064:  GOTO   057
0065:  RETURN
.................... #define lcd_rs_pin PIN_D4 
.................... #define lcd_rw_pin PIN_D5 
.................... #define lcd_enable_pin PIN_D6 
.................... #define lcd_data4 PIN_D0 
.................... #define lcd_data5 PIN_D1 
.................... #define lcd_data6 PIN_D2 
.................... #define lcd_data7 PIN_D3 
.................... #include <lcd.c>               //libreria manejo de la lcd 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00D6:  BSF    0F.0
....................    output_float(LCD_DATA5); 
00D7:  BSF    0F.1
....................    output_float(LCD_DATA6); 
00D8:  BSF    0F.2
....................    output_float(LCD_DATA7); 
00D9:  BSF    0F.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00DA:  MOVLB  02
00DB:  BSF    0F.5
00DC:  MOVLB  01
00DD:  BCF    0F.5
....................    delay_cycles(1); 
00DE:  NOP
....................    lcd_output_enable(1); 
00DF:  MOVLB  02
00E0:  BSF    0F.6
00E1:  MOVLB  01
00E2:  BCF    0F.6
....................    delay_cycles(1); 
00E3:  NOP
....................    high = lcd_read_nibble(); 
00E4:  MOVLB  00
00E5:  CALL   09B
00E6:  MOVF   78,W
00E7:  MOVLB  01
00E8:  MOVWF  39
....................        
....................    lcd_output_enable(0); 
00E9:  MOVLB  02
00EA:  BCF    0F.6
00EB:  MOVLB  01
00EC:  BCF    0F.6
....................    delay_cycles(1); 
00ED:  NOP
....................    lcd_output_enable(1); 
00EE:  MOVLB  02
00EF:  BSF    0F.6
00F0:  MOVLB  01
00F1:  BCF    0F.6
....................    delay_us(1); 
00F2:  NOP
....................    low = lcd_read_nibble(); 
00F3:  MOVLB  00
00F4:  CALL   09B
00F5:  MOVF   78,W
00F6:  MOVLB  01
00F7:  MOVWF  38
....................        
....................    lcd_output_enable(0); 
00F8:  MOVLB  02
00F9:  BCF    0F.6
00FA:  MOVLB  01
00FB:  BCF    0F.6
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00FC:  BCF    0F.0
....................    output_drive(LCD_DATA5); 
00FD:  BCF    0F.1
....................    output_drive(LCD_DATA6); 
00FE:  BCF    0F.2
....................    output_drive(LCD_DATA7); 
00FF:  BCF    0F.3
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0100:  SWAPF  39,W
0101:  MOVWF  77
0102:  MOVLW  F0
0103:  ANDWF  77,F
0104:  MOVF   77,W
0105:  IORWF  38,W
0106:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
009B:  MOVLB  01
009C:  CLRF   3A
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
009D:  BSF    0F.0
009E:  MOVLW  00
009F:  MOVLB  00
00A0:  BTFSC  0F.0
00A1:  MOVLW  01
00A2:  MOVLB  01
00A3:  IORWF  3A,F
....................    n |= input(LCD_DATA5) << 1; 
00A4:  BSF    0F.1
00A5:  MOVLW  00
00A6:  MOVLB  00
00A7:  BTFSC  0F.1
00A8:  MOVLW  01
00A9:  MOVWF  77
00AA:  BCF    03.0
00AB:  RLF    77,F
00AC:  MOVF   77,W
00AD:  MOVLB  01
00AE:  IORWF  3A,F
....................    n |= input(LCD_DATA6) << 2; 
00AF:  BSF    0F.2
00B0:  MOVLW  00
00B1:  MOVLB  00
00B2:  BTFSC  0F.2
00B3:  MOVLW  01
00B4:  MOVWF  77
00B5:  RLF    77,F
00B6:  RLF    77,F
00B7:  MOVLW  FC
00B8:  ANDWF  77,F
00B9:  MOVF   77,W
00BA:  MOVLB  01
00BB:  IORWF  3A,F
....................    n |= input(LCD_DATA7) << 3; 
00BC:  BSF    0F.3
00BD:  MOVLW  00
00BE:  MOVLB  00
00BF:  BTFSC  0F.3
00C0:  MOVLW  01
00C1:  MOVWF  77
00C2:  RLF    77,F
00C3:  RLF    77,F
00C4:  RLF    77,F
00C5:  MOVLW  F8
00C6:  ANDWF  77,F
00C7:  MOVF   77,W
00C8:  MOVLB  01
00C9:  IORWF  3A,F
....................     
....................    return(n); 
00CA:  MOVF   3A,W
00CB:  MOVWF  78
....................   #else 
00CC:  MOVLB  00
00CD:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0066:  MOVLB  01
0067:  BTFSC  39.0
0068:  GOTO   06D
0069:  MOVLB  02
006A:  BCF    0F.0
006B:  GOTO   06F
006C:  MOVLB  01
006D:  MOVLB  02
006E:  BSF    0F.0
006F:  MOVLB  01
0070:  BCF    0F.0
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0071:  BTFSC  39.1
0072:  GOTO   077
0073:  MOVLB  02
0074:  BCF    0F.1
0075:  GOTO   079
0076:  MOVLB  01
0077:  MOVLB  02
0078:  BSF    0F.1
0079:  MOVLB  01
007A:  BCF    0F.1
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
007B:  BTFSC  39.2
007C:  GOTO   081
007D:  MOVLB  02
007E:  BCF    0F.2
007F:  GOTO   083
0080:  MOVLB  01
0081:  MOVLB  02
0082:  BSF    0F.2
0083:  MOVLB  01
0084:  BCF    0F.2
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0085:  BTFSC  39.3
0086:  GOTO   08B
0087:  MOVLB  02
0088:  BCF    0F.3
0089:  GOTO   08D
008A:  MOVLB  01
008B:  MOVLB  02
008C:  BSF    0F.3
008D:  MOVLB  01
008E:  BCF    0F.3
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
008F:  NOP
....................    lcd_output_enable(1); 
0090:  MOVLB  02
0091:  BSF    0F.6
0092:  MOVLB  01
0093:  BCF    0F.6
....................    delay_us(2); 
0094:  GOTO   095
....................    lcd_output_enable(0); 
0095:  MOVLB  02
0096:  BCF    0F.6
0097:  MOVLB  01
0098:  BCF    0F.6
0099:  MOVLB  00
009A:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00CE:  MOVLB  01
00CF:  BCF    0F.6
....................    lcd_rs_tris(); 
00D0:  BCF    0F.4
....................    lcd_rw_tris(); 
00D1:  BCF    0F.5
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00D2:  MOVLB  02
00D3:  BCF    0F.4
00D4:  MOVLB  01
00D5:  BCF    0F.4
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0107:  MOVF   78,W
0108:  MOVWF  38
0109:  BTFSC  38.7
010A:  GOTO   0D6
....................    lcd_output_rs(address); 
010B:  MOVF   36,F
010C:  BTFSS  03.2
010D:  GOTO   112
010E:  MOVLB  02
010F:  BCF    0F.4
0110:  GOTO   114
0111:  MOVLB  01
0112:  MOVLB  02
0113:  BSF    0F.4
0114:  MOVLB  01
0115:  BCF    0F.4
....................    delay_cycles(1); 
0116:  NOP
....................    lcd_output_rw(0); 
0117:  MOVLB  02
0118:  BCF    0F.5
0119:  MOVLB  01
011A:  BCF    0F.5
....................    delay_cycles(1); 
011B:  NOP
....................    lcd_output_enable(0); 
011C:  MOVLB  02
011D:  BCF    0F.6
011E:  MOVLB  01
011F:  BCF    0F.6
....................    lcd_send_nibble(n >> 4); 
0120:  SWAPF  37,W
0121:  MOVWF  38
0122:  MOVLW  0F
0123:  ANDWF  38,F
0124:  MOVF   38,W
0125:  MOVWF  39
0126:  MOVLB  00
0127:  CALL   066
....................    lcd_send_nibble(n & 0xf); 
0128:  MOVLB  01
0129:  MOVF   37,W
012A:  ANDLW  0F
012B:  MOVWF  38
012C:  MOVWF  39
012D:  MOVLB  00
012E:  CALL   066
012F:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0130:  MOVLW  28
0131:  MOVLB  01
0132:  MOVWF  23
0133:  MOVLW  0C
0134:  MOVWF  24
0135:  MOVLW  01
0136:  MOVWF  25
0137:  MOVLW  06
0138:  MOVWF  26
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0139:  MOVLB  02
013A:  BCF    0F.6
013B:  MOVLB  01
013C:  BCF    0F.6
....................    lcd_output_rs(0); 
013D:  MOVLB  02
013E:  BCF    0F.4
013F:  MOVLB  01
0140:  BCF    0F.4
....................    lcd_output_rw(0); 
0141:  MOVLB  02
0142:  BCF    0F.5
0143:  MOVLB  01
0144:  BCF    0F.5
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0145:  BCF    0F.0
....................    output_drive(LCD_DATA5); 
0146:  BCF    0F.1
....................    output_drive(LCD_DATA6); 
0147:  BCF    0F.2
....................    output_drive(LCD_DATA7); 
0148:  BCF    0F.3
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0149:  BCF    0F.6
....................    lcd_rs_tris(); 
014A:  BCF    0F.4
....................    lcd_rw_tris(); 
014B:  BCF    0F.5
....................  #endif 
....................      
....................    delay_ms(15); 
014C:  MOVLW  0F
014D:  MOVWF  32
014E:  MOVLB  00
014F:  CALL   050
....................    for(i=1;i<=3;++i) 
0150:  MOVLW  01
0151:  MOVLB  01
0152:  MOVWF  22
0153:  MOVF   22,W
0154:  SUBLW  03
0155:  BTFSS  03.0
0156:  GOTO   163
....................    { 
....................        lcd_send_nibble(3); 
0157:  MOVLW  03
0158:  MOVWF  39
0159:  MOVLB  00
015A:  CALL   066
....................        delay_ms(5); 
015B:  MOVLW  05
015C:  MOVLB  01
015D:  MOVWF  32
015E:  MOVLB  00
015F:  CALL   050
0160:  MOVLB  01
0161:  INCF   22,F
0162:  GOTO   153
....................    } 
....................     
....................    lcd_send_nibble(2); 
0163:  MOVLW  02
0164:  MOVWF  39
0165:  MOVLB  00
0166:  CALL   066
....................    delay_ms(5); 
0167:  MOVLW  05
0168:  MOVLB  01
0169:  MOVWF  32
016A:  MOVLB  00
016B:  CALL   050
....................    for(i=0;i<=3;++i) 
016C:  MOVLB  01
016D:  CLRF   22
016E:  MOVF   22,W
016F:  SUBLW  03
0170:  BTFSS  03.0
0171:  GOTO   183
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0172:  MOVLW  53
0173:  ADDWF  22,W
0174:  MOVWF  04
0175:  MOVLW  20
0176:  MOVWF  05
0177:  BTFSC  03.0
0178:  INCF   05,F
0179:  MOVF   00,W
017A:  MOVWF  27
017B:  CLRF   36
017C:  MOVF   27,W
017D:  MOVWF  37
017E:  MOVLB  00
017F:  CALL   0CE
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0180:  MOVLB  01
0181:  INCF   22,F
0182:  GOTO   16E
0183:  MOVLP  00
0184:  MOVLB  00
0185:  GOTO   3CD (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
01B2:  MOVLB  01
01B3:  DECFSZ 33,W
01B4:  GOTO   1B6
01B5:  GOTO   1B9
....................       address=LCD_LINE_TWO; 
01B6:  MOVLW  40
01B7:  MOVWF  34
01B8:  GOTO   1BA
....................    else 
....................       address=0; 
01B9:  CLRF   34
....................       
....................    address+=x-1; 
01BA:  MOVLW  01
01BB:  SUBWF  32,W
01BC:  ADDWF  34,F
....................    lcd_send_byte(0,0x80|address); 
01BD:  MOVF   34,W
01BE:  IORLW  80
01BF:  MOVWF  35
01C0:  CLRF   36
01C1:  MOVF   35,W
01C2:  MOVWF  37
01C3:  MOVLB  00
01C4:  CALL   0CE
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01C5:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
01C6:  MOVLB  01
01C7:  MOVF   31,W
01C8:  XORLW  07
01C9:  MOVLB  00
01CA:  BTFSC  03.2
01CB:  GOTO   1D6
01CC:  XORLW  0B
01CD:  BTFSC  03.2
01CE:  GOTO   1DD
01CF:  XORLW  06
01D0:  BTFSC  03.2
01D1:  GOTO   1E9
01D2:  XORLW  02
01D3:  BTFSC  03.2
01D4:  GOTO   1F1
01D5:  GOTO   1F8
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01D6:  MOVLW  01
01D7:  MOVLB  01
01D8:  MOVWF  32
01D9:  MOVWF  33
01DA:  MOVLB  00
01DB:  CALL   1B2
01DC:  GOTO   1FF
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
01DD:  MOVLB  01
01DE:  CLRF   36
01DF:  MOVLW  01
01E0:  MOVWF  37
01E1:  MOVLB  00
01E2:  CALL   0CE
....................                      delay_ms(2); 
01E3:  MOVLW  02
01E4:  MOVLB  01
01E5:  MOVWF  32
01E6:  MOVLB  00
01E7:  CALL   050
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
01E8:  GOTO   1FF
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01E9:  MOVLW  01
01EA:  MOVLB  01
01EB:  MOVWF  32
01EC:  MOVLW  02
01ED:  MOVWF  33
01EE:  MOVLB  00
01EF:  CALL   1B2
01F0:  GOTO   1FF
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
01F1:  MOVLB  01
01F2:  CLRF   36
01F3:  MOVLW  10
01F4:  MOVWF  37
01F5:  MOVLB  00
01F6:  CALL   0CE
01F7:  GOTO   1FF
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
01F8:  MOVLW  01
01F9:  MOVLB  01
01FA:  MOVWF  36
01FB:  MOVF   31,W
01FC:  MOVWF  37
01FD:  MOVLB  00
01FE:  CALL   0CE
....................      #endif 
....................    } 
01FF:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
*
0186:  MOVLB  01
0187:  RLF    22,F
0188:  RLF    22,F
0189:  RLF    22,F
018A:  MOVLW  F8
018B:  ANDWF  22,F
....................    which &= 0x38; 
018C:  MOVLW  38
018D:  ANDWF  22,F
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
018E:  MOVF   22,W
018F:  IORLW  40
0190:  MOVWF  26
0191:  CLRF   36
0192:  MOVF   26,W
0193:  MOVWF  37
0194:  MOVLB  00
0195:  CALL   0CE
....................  
....................    for(i=0; i<8; i++) 
0196:  MOVLB  01
0197:  CLRF   25
0198:  MOVF   25,W
0199:  SUBLW  07
019A:  BTFSS  03.0
019B:  GOTO   1B0
....................    { 
....................       lcd_send_byte(1, *ptr++); 
019C:  MOVF   24,W
019D:  MOVWF  7A
019E:  MOVF   23,W
019F:  INCF   23,F
01A0:  BTFSC  03.2
01A1:  INCF   24,F
01A2:  MOVWF  04
01A3:  MOVF   7A,W
01A4:  MOVWF  05
01A5:  MOVF   00,W
01A6:  MOVWF  26
01A7:  MOVLW  01
01A8:  MOVWF  36
01A9:  MOVF   26,W
01AA:  MOVWF  37
01AB:  MOVLB  00
01AC:  CALL   0CE
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
01AD:  MOVLB  01
01AE:  INCF   25,F
01AF:  GOTO   198
01B0:  MOVLB  00
01B1:  RETURN
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #define TONE_PIN  PIN_B3 
....................  
....................  
.................... int 
.................... character1[8] = {7,23,22,31,14,10,15,0},//dino completo 
.................... character2[8] = {7,23,22,31,14,2,3,0},// dino sin pata izquierda 
.................... character3[8] = {7,23,22,31,14,8,12,0},// dino sin pata derecha 
.................... character4[8] = {6,22,22,30,30,6,6,31}, //cactus grande 
.................... character5[8] = {0,0,12,13,15,12,12,31}, //cactus chico 
.................... character6[8] = {29,28,25,2,20,0,0,0}, //sol 1 
.................... character7[8] = {28,29,24,2,8,0,0,0};  // sol 2 
....................  
.................... /////////////////// variables para el juego 
.................... int randon;  
.................... int16 puntuacion=0; 
.................... int16 final=0; 
.................... int16  record=0; 
.................... int16 record1=0; 
.................... signed int16 cac; 
.................... signed int16 gua; 
.................... int guar=0; 
....................     
....................            int delay=0, delay1=0, delay2=0; //declaramos las variables para  
.................... 	///despues poder modificar la velocidad 
....................             
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... void principal (){   ///programa principal que contiene la mayoria de  
.................... ///las funciones del codigo 
....................  
....................  
....................  for (cac=16; cac>0; cac--){ //for para que los cactus se recorran 
*
0800:  CLRF   68
0801:  MOVLW  10
0802:  MOVWF  67
0803:  BTFSC  68.7
0804:  GOTO   70E
0805:  MOVF   68,F
0806:  BTFSS  03.2
0807:  GOTO   00C
0808:  MOVF   67,W
0809:  SUBLW  00
080A:  BTFSC  03.0
080B:  GOTO   70E
....................       
....................       
....................       
....................    if(cac==2){           ///////sonidos de perder 
080C:  MOVF   67,W
080D:  SUBLW  02
080E:  BTFSS  03.2
080F:  GOTO   153
0810:  MOVF   68,F
0811:  BTFSS  03.2
0812:  GOTO   153
....................         output_high (PIN_B3);   ///encender la bocina conectada al pin B3 
0813:  MOVLB  01
0814:  BCF    0D.3
0815:  MOVLB  02
0816:  BSF    0D.3
....................      delay_ms(5);               //mantener 5 ms 
0817:  MOVLW  05
0818:  MOVLB  01
0819:  MOVWF  32
081A:  MOVLP  00
081B:  MOVLB  00
081C:  CALL   050
081D:  MOVLP  08
....................         output_low (PIN_B3);	///apagar la bocina conectada al pin B3 
081E:  MOVLB  01
081F:  BCF    0D.3
0820:  MOVLB  02
0821:  BCF    0D.3
....................          delay_ms(5); 		 //mantener 5 ms 
0822:  MOVLW  05
0823:  MOVLB  01
0824:  MOVWF  32
0825:  MOVLP  00
0826:  MOVLB  00
0827:  CALL   050
0828:  MOVLP  08
....................          
....................          output_high (PIN_B3);	 ///encender la bocina conectada al pin B3 
0829:  MOVLB  01
082A:  BCF    0D.3
082B:  MOVLB  02
082C:  BSF    0D.3
....................      delay_ms(5);  		//mantener 5 ms 
082D:  MOVLW  05
082E:  MOVLB  01
082F:  MOVWF  32
0830:  MOVLP  00
0831:  MOVLB  00
0832:  CALL   050
0833:  MOVLP  08
....................         output_low (PIN_B3);	///apagar la bocina conectada al pin B3 
0834:  MOVLB  01
0835:  BCF    0D.3
0836:  MOVLB  02
0837:  BCF    0D.3
....................          delay_ms(5); 		//mantener 5 ms 
0838:  MOVLW  05
0839:  MOVLB  01
083A:  MOVWF  32
083B:  MOVLP  00
083C:  MOVLB  00
083D:  CALL   050
083E:  MOVLP  08
....................           
....................           
....................          output_high (PIN_B3);	 ///encender la bocina conectada al pin B3 
083F:  MOVLB  01
0840:  BCF    0D.3
0841:  MOVLB  02
0842:  BSF    0D.3
....................      delay_ms(5);  		//mantener 5 ms 
0843:  MOVLW  05
0844:  MOVLB  01
0845:  MOVWF  32
0846:  MOVLP  00
0847:  MOVLB  00
0848:  CALL   050
0849:  MOVLP  08
....................         output_low (PIN_B3);	///apagar la bocina conectada al pin B3 
084A:  MOVLB  01
084B:  BCF    0D.3
084C:  MOVLB  02
084D:  BCF    0D.3
....................          delay_ms(5); 		//mantener 5 ms 
084E:  MOVLW  05
084F:  MOVLB  01
0850:  MOVWF  32
0851:  MOVLP  00
0852:  MOVLB  00
0853:  CALL   050
0854:  MOVLP  08
....................           
....................           
....................          output_high (PIN_B3);	 ///encender la bocina conectada al pin B3 
0855:  MOVLB  01
0856:  BCF    0D.3
0857:  MOVLB  02
0858:  BSF    0D.3
....................      delay_ms(5);  		//mantener 5 ms 
0859:  MOVLW  05
085A:  MOVLB  01
085B:  MOVWF  32
085C:  MOVLP  00
085D:  MOVLB  00
085E:  CALL   050
085F:  MOVLP  08
....................         output_low (PIN_B3);	///apagar la bocina conectada al pin B3 
0860:  MOVLB  01
0861:  BCF    0D.3
0862:  MOVLB  02
0863:  BCF    0D.3
....................          
....................          
....................        cac=2;  			//mantenemos la variable cac en un valor de 2  
0864:  MOVLB  00
0865:  CLRF   68
0866:  MOVLW  02
0867:  MOVWF  67
....................        
....................     lcd_putc("\f" ) ; 		//limpiar la pantalla  
0868:  MOVLW  03
0869:  MOVLB  03
086A:  MOVWF  11
086B:  MOVLW  00
086C:  MOVWF  12
086D:  MOVLP  00
086E:  MOVLB  00
086F:  CALL   200
0870:  MOVLP  08
....................           lcd_gotoxy(5,1);	//apuntar a la posicin x=5 y y=1 
0871:  MOVLW  05
0872:  MOVLB  01
0873:  MOVWF  32
0874:  MOVLW  01
0875:  MOVWF  33
0876:  MOVLP  00
0877:  MOVLB  00
0878:  CALL   1B2
0879:  MOVLP  08
....................        lcd_putc("Perdiste" ) ;	//imprimir  mensaje 
087A:  MOVLW  04
087B:  MOVLB  03
087C:  MOVWF  11
087D:  MOVLW  00
087E:  MOVWF  12
087F:  MOVLP  00
0880:  MOVLB  00
0881:  CALL   200
0882:  MOVLP  08
....................       
....................   
....................           if ((record<puntuacion)&& (record1<final)){ //comparar si la puntucin anterior  
0883:  MOVF   64,W
0884:  SUBWF  60,W
0885:  BTFSS  03.0
0886:  GOTO   0EF
0887:  BTFSS  03.2
0888:  GOTO   08D
0889:  MOVF   5F,W
088A:  SUBWF  63,W
088B:  BTFSC  03.0
088C:  GOTO   0EF
088D:  MOVF   66,W
088E:  SUBWF  62,W
088F:  BTFSS  03.0
0890:  GOTO   0EF
0891:  BTFSS  03.2
0892:  GOTO   097
0893:  MOVF   61,W
0894:  SUBWF  65,W
0895:  BTFSC  03.0
0896:  GOTO   0EF
.................... 							// es ms pequea que la puntuacin actual 
....................               while (input(PIN_B0)==1){    //entrar a un ciclo donde se debe de oprimir el boton en B0 
0897:  MOVLB  01
0898:  BSF    0D.0
0899:  MOVLB  00
089A:  BTFSS  0D.0
089B:  GOTO   0E2
.................... 					   // para salir e iniciar un nuevo juego 
....................               lcd_gotoxy(1,2);		   //apunta a la posicin   
089C:  MOVLW  01
089D:  MOVLB  01
089E:  MOVWF  32
089F:  MOVLW  02
08A0:  MOVWF  33
08A1:  MOVLP  00
08A2:  MOVLB  00
08A3:  CALL   1B2
08A4:  MOVLP  08
....................       printf(lcd_putc,"New Record!:%3Lu%Lu",final,  puntuacion);  //imprimir mensaje junto con dos variables 
08A5:  MOVLW  09
08A6:  MOVLB  03
08A7:  MOVWF  11
08A8:  MOVLW  00
08A9:  MOVWF  12
08AA:  BCF    03.0
08AB:  MOVLW  0C
08AC:  MOVLB  01
08AD:  MOVWF  24
08AE:  MOVLP  00
08AF:  MOVLB  00
08B0:  CALL   264
08B1:  MOVLP  08
08B2:  MOVLW  02
08B3:  MOVWF  04
08B4:  MOVF   62,W
08B5:  MOVLB  01
08B6:  MOVWF  25
08B7:  MOVLB  00
08B8:  MOVF   61,W
08B9:  MOVLB  01
08BA:  MOVWF  24
08BB:  MOVLP  00
08BC:  MOVLB  00
08BD:  CALL   2BC
08BE:  MOVLP  08
08BF:  MOVLW  10
08C0:  MOVWF  04
08C1:  MOVF   60,W
08C2:  MOVLB  01
08C3:  MOVWF  25
08C4:  MOVLB  00
08C5:  MOVF   5F,W
08C6:  MOVLB  01
08C7:  MOVWF  24
08C8:  MOVLP  00
08C9:  MOVLB  00
08CA:  CALL   2BC
08CB:  MOVLP  08
....................         record=puntuacion ;  //almacenamos la puntuacin ms alta en la variable record 
08CC:  MOVF   60,W
08CD:  MOVWF  64
08CE:  MOVF   5F,W
08CF:  MOVWF  63
....................         record1=final;  //lamacenamos la variable final ms alta en record1 
08D0:  MOVF   62,W
08D1:  MOVWF  66
08D2:  MOVF   61,W
08D3:  MOVWF  65
....................          
....................         delay_ms(500); //mantenemos este ciclo durante 500ms 
08D4:  MOVLW  02
08D5:  MOVLB  01
08D6:  MOVWF  24
08D7:  MOVLW  FA
08D8:  MOVWF  32
08D9:  MOVLP  00
08DA:  MOVLB  00
08DB:  CALL   050
08DC:  MOVLP  08
08DD:  MOVLB  01
08DE:  DECFSZ 24,F
08DF:  GOTO   0D7
08E0:  GOTO   098
08E1:  MOVLB  00
....................           
....................               } //Fin de while 
....................  
....................  
....................                lcd_putc("\f" ) ; //limpiamos pantalla 
08E2:  MOVLW  13
08E3:  MOVLB  03
08E4:  MOVWF  11
08E5:  MOVLW  00
08E6:  MOVWF  12
08E7:  MOVLP  00
08E8:  MOVLB  00
08E9:  CALL   200
08EA:  MOVLP  08
....................                puntuacion=0;  //limpiamos la varible puntuacin 
08EB:  CLRF   60
08EC:  CLRF   5F
....................           	final=0; //limpiar final 
08ED:  CLRF   62
08EE:  CLRF   61
.................... 	} //fin de If 
....................              
....................                
....................                
....................               if((record>=puntuacion)&& (record1>=final)){ //checar sipuntuacin y final son 
08EF:  MOVF   60,W
08F0:  SUBWF  64,W
08F1:  BTFSS  03.0
08F2:  GOTO   153
08F3:  BTFSS  03.2
08F4:  GOTO   0F9
08F5:  MOVF   5F,W
08F6:  SUBWF  63,W
08F7:  BTFSS  03.0
08F8:  GOTO   153
08F9:  MOVF   62,W
08FA:  SUBWF  66,W
08FB:  BTFSS  03.0
08FC:  GOTO   153
08FD:  BTFSS  03.2
08FE:  GOTO   103
08FF:  MOVF   61,W
0900:  SUBWF  65,W
0901:  BTFSS  03.0
0902:  GOTO   153
.................... 								//ms pequeas que el record 
....................                while (input(PIN_B0)==1){   //salir del ciclo cuando se precione B0     
0903:  MOVLB  01
0904:  BSF    0D.0
0905:  MOVLB  00
0906:  BTFSS  0D.0
0907:  GOTO   146
....................               lcd_gotoxy(1,2);		//apunta ala posicin x=1 y=2 de la pantalla LCD 
0908:  MOVLW  01
0909:  MOVLB  01
090A:  MOVWF  32
090B:  MOVLW  02
090C:  MOVWF  33
090D:  MOVLP  00
090E:  MOVLB  00
090F:  CALL   1B2
0910:  MOVLP  08
....................       printf(lcd_putc,"Puntuacion:%3Lu%Lu",final,  puntuacion); //Imprime mensajecon dos variables 
0911:  MOVLW  14
0912:  MOVLB  03
0913:  MOVWF  11
0914:  MOVLW  00
0915:  MOVWF  12
0916:  BCF    03.0
0917:  MOVLW  0B
0918:  MOVLB  01
0919:  MOVWF  24
091A:  MOVLP  00
091B:  MOVLB  00
091C:  CALL   264
091D:  MOVLP  08
091E:  MOVLW  02
091F:  MOVWF  04
0920:  MOVF   62,W
0921:  MOVLB  01
0922:  MOVWF  25
0923:  MOVLB  00
0924:  MOVF   61,W
0925:  MOVLB  01
0926:  MOVWF  24
0927:  MOVLP  00
0928:  MOVLB  00
0929:  CALL   2BC
092A:  MOVLP  08
092B:  MOVLW  10
092C:  MOVWF  04
092D:  MOVF   60,W
092E:  MOVLB  01
092F:  MOVWF  25
0930:  MOVLB  00
0931:  MOVF   5F,W
0932:  MOVLB  01
0933:  MOVWF  24
0934:  MOVLP  00
0935:  MOVLB  00
0936:  CALL   2BC
0937:  MOVLP  08
....................        delay_ms(500);  //mantener  500ms 
0938:  MOVLW  02
0939:  MOVLB  01
093A:  MOVWF  24
093B:  MOVLW  FA
093C:  MOVWF  32
093D:  MOVLP  00
093E:  MOVLB  00
093F:  CALL   050
0940:  MOVLP  08
0941:  MOVLB  01
0942:  DECFSZ 24,F
0943:  GOTO   13B
0944:  GOTO   104
0945:  MOVLB  00
....................    
....................           
....................               } //Fin while 
....................                        lcd_putc("\f" ) ; //limpiar pantalla 
0946:  MOVLW  1E
0947:  MOVLB  03
0948:  MOVWF  11
0949:  MOVLW  00
094A:  MOVWF  12
094B:  MOVLP  00
094C:  MOVLB  00
094D:  CALL   200
094E:  MOVLP  08
....................                 puntuacion=0; //limpar puntuacin  
094F:  CLRF   60
0950:  CLRF   5F
....................                 final=0; //limpiar final 
0951:  CLRF   62
0952:  CLRF   61
....................               } //Fin if 
....................        
....................             
....................             
....................        
....................        
....................       
....................            
.................... } 
....................    //velocidad 
....................    if(final<2) //si se tiene menos de 20 puntos  
0953:  MOVF   62,F
0954:  BTFSS  03.2
0955:  GOTO   160
0956:  MOVF   61,W
0957:  SUBLW  01
0958:  BTFSS  03.0
0959:  GOTO   160
....................    { 
....................        delay=40; 
095A:  MOVLW  28
095B:  MOVWF  6C
....................        delay1=20; //velocidad baja 
095C:  MOVLW  14
095D:  MOVWF  6D
....................        delay2=10; 
095E:  MOVLW  0A
095F:  MOVWF  6E
....................         
....................    } 
....................  
....................    if((final<5)&&(final>2)) //si se tiene menos de 50 puntos y ms de 20  
0960:  MOVF   62,F
0961:  BTFSS  03.2
0962:  GOTO   174
0963:  MOVF   61,W
0964:  SUBLW  04
0965:  BTFSS  03.0
0966:  GOTO   174
0967:  MOVF   62,F
0968:  BTFSS  03.2
0969:  GOTO   16E
096A:  MOVF   61,W
096B:  SUBLW  02
096C:  BTFSC  03.0
096D:  GOTO   174
....................    { 
....................        delay=30; 
096E:  MOVLW  1E
096F:  MOVWF  6C
....................        delay1=15; //velocidad media  
0970:  MOVLW  0F
0971:  MOVWF  6D
....................        delay2=8;  
0972:  MOVLW  08
0973:  MOVWF  6E
....................    } 
....................  
....................    if((final<7)&&(final>5)) //si se tiene menos de 70 puntos y ms de 50  
0974:  MOVF   62,F
0975:  BTFSS  03.2
0976:  GOTO   188
0977:  MOVF   61,W
0978:  SUBLW  06
0979:  BTFSS  03.0
097A:  GOTO   188
097B:  MOVF   62,F
097C:  BTFSS  03.2
097D:  GOTO   182
097E:  MOVF   61,W
097F:  SUBLW  05
0980:  BTFSC  03.0
0981:  GOTO   188
....................    { 
....................        delay=20; 
0982:  MOVLW  14
0983:  MOVWF  6C
....................        delay1=10; //velocidad alta 
0984:  MOVLW  0A
0985:  MOVWF  6D
....................        delay2=5; 
0986:  MOVLW  05
0987:  MOVWF  6E
....................         
....................    } 
....................  
....................    if((final<10)&&(final>7))  //si se tiene menos de 100 puntos y ms de 70  
0988:  MOVF   62,F
0989:  BTFSS  03.2
098A:  GOTO   19C
098B:  MOVF   61,W
098C:  SUBLW  09
098D:  BTFSS  03.0
098E:  GOTO   19C
098F:  MOVF   62,F
0990:  BTFSS  03.2
0991:  GOTO   196
0992:  MOVF   61,W
0993:  SUBLW  07
0994:  BTFSC  03.0
0995:  GOTO   19C
....................    { 
....................        delay=10; 
0996:  MOVLW  0A
0997:  MOVWF  6C
....................        delay1=5; //velocidad ms alta 
0998:  MOVLW  05
0999:  MOVWF  6D
....................        delay2=3; 
099A:  MOVLW  03
099B:  MOVWF  6E
....................         
....................    } 
....................    if(final>10)  //si se tiene mas de 100 puntos  
099C:  MOVF   62,F
099D:  BTFSS  03.2
099E:  GOTO   1A3
099F:  MOVF   61,W
09A0:  SUBLW  0A
09A1:  BTFSC  03.0
09A2:  GOTO   1A9
....................    { 
....................        delay=6; 
09A3:  MOVLW  06
09A4:  MOVWF  6C
....................        delay1=3; //velocidad final 
09A5:  MOVLW  03
09A6:  MOVWF  6D
....................        delay2=2; 
09A7:  MOVLW  02
09A8:  MOVWF  6E
....................         
....................    } 
....................     
....................  
.................... //GENERAR ESCENARIO RANDOM 
....................    
....................   
....................    if (cac==16){ //solo se generan cuando inicia el ciclo de recorrer los cactus 
09A9:  MOVF   67,W
09AA:  SUBLW  10
09AB:  BTFSS  03.2
09AC:  GOTO   238
09AD:  MOVF   68,F
09AE:  BTFSS  03.2
09AF:  GOTO   238
....................     randon=(rand()%7); //elegir un nmero entre 0 y 6 
*
0A26:  MOVF   79,W
0A27:  MOVLB  01
0A28:  MOVWF  25
0A29:  MOVF   78,W
0A2A:  MOVWF  24
0A2B:  MOVF   25,W
0A2C:  MOVWF  28
0A2D:  MOVF   24,W
0A2E:  MOVWF  27
0A2F:  CLRF   2A
0A30:  MOVLW  07
0A31:  MOVWF  29
0A32:  MOVLP  00
0A33:  MOVLB  00
0A34:  CALL   325
0A35:  MOVLP  08
0A36:  MOVF   77,W
0A37:  MOVWF  5E
....................    } 
....................  
....................      if (randon==0){  //si el nmero es 0 
0A38:  MOVF   5E,F
0A39:  BTFSS  03.2
0A3A:  GOTO   26A
....................      lcd_gotoxy(cac,2); 
0A3B:  MOVF   67,W
0A3C:  MOVLB  01
0A3D:  MOVWF  32
0A3E:  MOVLW  02
0A3F:  MOVWF  33
0A40:  MOVLP  00
0A41:  MOVLB  00
0A42:  CALL   1B2
0A43:  MOVLP  08
....................                      printf(lcd_putc, "%c",4);////cactus 
0A44:  MOVLW  04
0A45:  MOVLB  01
0A46:  MOVWF  31
0A47:  MOVLP  00
0A48:  MOVLB  00
0A49:  CALL   1C6
0A4A:  MOVLP  08
.................... delay_ms(delay2); 
0A4B:  MOVF   6E,W
0A4C:  MOVLB  01
0A4D:  MOVWF  32
0A4E:  MOVLP  00
0A4F:  MOVLB  00
0A50:  CALL   050
0A51:  MOVLP  08
....................                         lcd_gotoxy(cac+1,2);///////borrar 
0A52:  MOVLW  01
0A53:  ADDWF  67,W
0A54:  MOVLB  01
0A55:  MOVWF  24
0A56:  MOVLW  00
0A57:  MOVLB  00
0A58:  ADDWFC 68,W
0A59:  MOVLB  01
0A5A:  MOVWF  25
0A5B:  MOVF   24,W
0A5C:  MOVWF  32
0A5D:  MOVLW  02
0A5E:  MOVWF  33
0A5F:  MOVLP  00
0A60:  MOVLB  00
0A61:  CALL   1B2
0A62:  MOVLP  08
....................                      printf(lcd_putc, " "); 
0A63:  MOVLW  20
0A64:  MOVLB  01
0A65:  MOVWF  31
0A66:  MOVLP  00
0A67:  MOVLB  00
0A68:  CALL   1C6
0A69:  MOVLP  08
.................... } 
....................  
....................  
.................... if (randon==1){ //si el nmero es 1 
0A6A:  DECFSZ 5E,W
0A6B:  GOTO   29B
....................      lcd_gotoxy(cac,2); 
0A6C:  MOVF   67,W
0A6D:  MOVLB  01
0A6E:  MOVWF  32
0A6F:  MOVLW  02
0A70:  MOVWF  33
0A71:  MOVLP  00
0A72:  MOVLB  00
0A73:  CALL   1B2
0A74:  MOVLP  08
....................                      printf(lcd_putc, "%c",3);////cactus 
0A75:  MOVLW  03
0A76:  MOVLB  01
0A77:  MOVWF  31
0A78:  MOVLP  00
0A79:  MOVLB  00
0A7A:  CALL   1C6
0A7B:  MOVLP  08
....................                        delay_ms(delay2); 
0A7C:  MOVF   6E,W
0A7D:  MOVLB  01
0A7E:  MOVWF  32
0A7F:  MOVLP  00
0A80:  MOVLB  00
0A81:  CALL   050
0A82:  MOVLP  08
....................                         lcd_gotoxy(cac+1,2);///////borrar 
0A83:  MOVLW  01
0A84:  ADDWF  67,W
0A85:  MOVLB  01
0A86:  MOVWF  24
0A87:  MOVLW  00
0A88:  MOVLB  00
0A89:  ADDWFC 68,W
0A8A:  MOVLB  01
0A8B:  MOVWF  25
0A8C:  MOVF   24,W
0A8D:  MOVWF  32
0A8E:  MOVLW  02
0A8F:  MOVWF  33
0A90:  MOVLP  00
0A91:  MOVLB  00
0A92:  CALL   1B2
0A93:  MOVLP  08
....................                      printf(lcd_putc, " "); 
0A94:  MOVLW  20
0A95:  MOVLB  01
0A96:  MOVWF  31
0A97:  MOVLP  00
0A98:  MOVLB  00
0A99:  CALL   1C6
0A9A:  MOVLP  08
.................... } 
....................  
.................... if (randon==2){  //si el nmero es 2 
0A9B:  MOVF   5E,W
0A9C:  SUBLW  02
0A9D:  BTFSS  03.2
0A9E:  GOTO   2D5
....................      lcd_gotoxy(cac,2); 
0A9F:  MOVF   67,W
0AA0:  MOVLB  01
0AA1:  MOVWF  32
0AA2:  MOVLW  02
0AA3:  MOVWF  33
0AA4:  MOVLP  00
0AA5:  MOVLB  00
0AA6:  CALL   1B2
0AA7:  MOVLP  08
....................                      printf(lcd_putc, "%c%c",4,3);////cactus 
0AA8:  MOVLW  04
0AA9:  MOVLB  01
0AAA:  MOVWF  31
0AAB:  MOVLP  00
0AAC:  MOVLB  00
0AAD:  CALL   1C6
0AAE:  MOVLP  08
0AAF:  MOVLW  03
0AB0:  MOVLB  01
0AB1:  MOVWF  31
0AB2:  MOVLP  00
0AB3:  MOVLB  00
0AB4:  CALL   1C6
0AB5:  MOVLP  08
....................                      delay_ms(delay2); 
0AB6:  MOVF   6E,W
0AB7:  MOVLB  01
0AB8:  MOVWF  32
0AB9:  MOVLP  00
0ABA:  MOVLB  00
0ABB:  CALL   050
0ABC:  MOVLP  08
....................                         lcd_gotoxy(cac+2,2);///////borrar 
0ABD:  MOVLW  02
0ABE:  ADDWF  67,W
0ABF:  MOVLB  01
0AC0:  MOVWF  24
0AC1:  MOVLW  00
0AC2:  MOVLB  00
0AC3:  ADDWFC 68,W
0AC4:  MOVLB  01
0AC5:  MOVWF  25
0AC6:  MOVF   24,W
0AC7:  MOVWF  32
0AC8:  MOVLW  02
0AC9:  MOVWF  33
0ACA:  MOVLP  00
0ACB:  MOVLB  00
0ACC:  CALL   1B2
0ACD:  MOVLP  08
....................                      printf(lcd_putc, " "); 
0ACE:  MOVLW  20
0ACF:  MOVLB  01
0AD0:  MOVWF  31
0AD1:  MOVLP  00
0AD2:  MOVLB  00
0AD3:  CALL   1C6
0AD4:  MOVLP  08
.................... } 
....................  
.................... if (randon==3){   //si el nmero es 3 
0AD5:  MOVF   5E,W
0AD6:  SUBLW  03
0AD7:  BTFSS  03.2
0AD8:  GOTO   30F
....................      lcd_gotoxy(cac,2); 
0AD9:  MOVF   67,W
0ADA:  MOVLB  01
0ADB:  MOVWF  32
0ADC:  MOVLW  02
0ADD:  MOVWF  33
0ADE:  MOVLP  00
0ADF:  MOVLB  00
0AE0:  CALL   1B2
0AE1:  MOVLP  08
....................                      printf(lcd_putc, "%c%c",3,4);////cactus 
0AE2:  MOVLW  03
0AE3:  MOVLB  01
0AE4:  MOVWF  31
0AE5:  MOVLP  00
0AE6:  MOVLB  00
0AE7:  CALL   1C6
0AE8:  MOVLP  08
0AE9:  MOVLW  04
0AEA:  MOVLB  01
0AEB:  MOVWF  31
0AEC:  MOVLP  00
0AED:  MOVLB  00
0AEE:  CALL   1C6
0AEF:  MOVLP  08
....................                      delay_ms(delay2); 
0AF0:  MOVF   6E,W
0AF1:  MOVLB  01
0AF2:  MOVWF  32
0AF3:  MOVLP  00
0AF4:  MOVLB  00
0AF5:  CALL   050
0AF6:  MOVLP  08
....................                         lcd_gotoxy(cac+2,2);///////borrar 
0AF7:  MOVLW  02
0AF8:  ADDWF  67,W
0AF9:  MOVLB  01
0AFA:  MOVWF  24
0AFB:  MOVLW  00
0AFC:  MOVLB  00
0AFD:  ADDWFC 68,W
0AFE:  MOVLB  01
0AFF:  MOVWF  25
0B00:  MOVF   24,W
0B01:  MOVWF  32
0B02:  MOVLW  02
0B03:  MOVWF  33
0B04:  MOVLP  00
0B05:  MOVLB  00
0B06:  CALL   1B2
0B07:  MOVLP  08
....................                      printf(lcd_putc, " "); 
0B08:  MOVLW  20
0B09:  MOVLB  01
0B0A:  MOVWF  31
0B0B:  MOVLP  00
0B0C:  MOVLB  00
0B0D:  CALL   1C6
0B0E:  MOVLP  08
.................... } 
.................... if (randon==4){    //si el nmero es 4 
0B0F:  MOVF   5E,W
0B10:  SUBLW  04
0B11:  BTFSS  03.2
0B12:  GOTO   350
....................      lcd_gotoxy(cac,2);  
0B13:  MOVF   67,W
0B14:  MOVLB  01
0B15:  MOVWF  32
0B16:  MOVLW  02
0B17:  MOVWF  33
0B18:  MOVLP  00
0B19:  MOVLB  00
0B1A:  CALL   1B2
0B1B:  MOVLP  08
....................                      printf(lcd_putc, "%c%c%c",4,3,4);////cactus 
0B1C:  MOVLW  04
0B1D:  MOVLB  01
0B1E:  MOVWF  31
0B1F:  MOVLP  00
0B20:  MOVLB  00
0B21:  CALL   1C6
0B22:  MOVLP  08
0B23:  MOVLW  03
0B24:  MOVLB  01
0B25:  MOVWF  31
0B26:  MOVLP  00
0B27:  MOVLB  00
0B28:  CALL   1C6
0B29:  MOVLP  08
0B2A:  MOVLW  04
0B2B:  MOVLB  01
0B2C:  MOVWF  31
0B2D:  MOVLP  00
0B2E:  MOVLB  00
0B2F:  CALL   1C6
0B30:  MOVLP  08
....................                      delay_ms(delay2); 
0B31:  MOVF   6E,W
0B32:  MOVLB  01
0B33:  MOVWF  32
0B34:  MOVLP  00
0B35:  MOVLB  00
0B36:  CALL   050
0B37:  MOVLP  08
....................                         lcd_gotoxy(cac+3,2);///////borrar 
0B38:  MOVLW  03
0B39:  ADDWF  67,W
0B3A:  MOVLB  01
0B3B:  MOVWF  24
0B3C:  MOVLW  00
0B3D:  MOVLB  00
0B3E:  ADDWFC 68,W
0B3F:  MOVLB  01
0B40:  MOVWF  25
0B41:  MOVF   24,W
0B42:  MOVWF  32
0B43:  MOVLW  02
0B44:  MOVWF  33
0B45:  MOVLP  00
0B46:  MOVLB  00
0B47:  CALL   1B2
0B48:  MOVLP  08
....................                      printf(lcd_putc, " "); //limpiar 
0B49:  MOVLW  20
0B4A:  MOVLB  01
0B4B:  MOVWF  31
0B4C:  MOVLP  00
0B4D:  MOVLB  00
0B4E:  CALL   1C6
0B4F:  MOVLP  08
....................                   
.................... } 
....................  
.................... if (randon==5){   //si el nmero es 5 
0B50:  MOVF   5E,W
0B51:  SUBLW  05
0B52:  BTFSS  03.2
0B53:  GOTO   391
....................      lcd_gotoxy(cac,2); 
0B54:  MOVF   67,W
0B55:  MOVLB  01
0B56:  MOVWF  32
0B57:  MOVLW  02
0B58:  MOVWF  33
0B59:  MOVLP  00
0B5A:  MOVLB  00
0B5B:  CALL   1B2
0B5C:  MOVLP  08
....................                      printf(lcd_putc, "%c%c%c",3,4,3);////cactus 
0B5D:  MOVLW  03
0B5E:  MOVLB  01
0B5F:  MOVWF  31
0B60:  MOVLP  00
0B61:  MOVLB  00
0B62:  CALL   1C6
0B63:  MOVLP  08
0B64:  MOVLW  04
0B65:  MOVLB  01
0B66:  MOVWF  31
0B67:  MOVLP  00
0B68:  MOVLB  00
0B69:  CALL   1C6
0B6A:  MOVLP  08
0B6B:  MOVLW  03
0B6C:  MOVLB  01
0B6D:  MOVWF  31
0B6E:  MOVLP  00
0B6F:  MOVLB  00
0B70:  CALL   1C6
0B71:  MOVLP  08
....................                      delay_ms(delay2); 
0B72:  MOVF   6E,W
0B73:  MOVLB  01
0B74:  MOVWF  32
0B75:  MOVLP  00
0B76:  MOVLB  00
0B77:  CALL   050
0B78:  MOVLP  08
....................                         lcd_gotoxy(cac+3,2);///////borrar 
0B79:  MOVLW  03
0B7A:  ADDWF  67,W
0B7B:  MOVLB  01
0B7C:  MOVWF  24
0B7D:  MOVLW  00
0B7E:  MOVLB  00
0B7F:  ADDWFC 68,W
0B80:  MOVLB  01
0B81:  MOVWF  25
0B82:  MOVF   24,W
0B83:  MOVWF  32
0B84:  MOVLW  02
0B85:  MOVWF  33
0B86:  MOVLP  00
0B87:  MOVLB  00
0B88:  CALL   1B2
0B89:  MOVLP  08
....................                      printf(lcd_putc, " "); 
0B8A:  MOVLW  20
0B8B:  MOVLB  01
0B8C:  MOVWF  31
0B8D:  MOVLP  00
0B8E:  MOVLB  00
0B8F:  CALL   1C6
0B90:  MOVLP  08
.................... } 
.................... if (randon==6){   //si el nmero es 6 
0B91:  MOVF   5E,W
0B92:  SUBLW  06
0B93:  BTFSS  03.2
0B94:  GOTO   3CB
....................      lcd_gotoxy(cac,2); 
0B95:  MOVF   67,W
0B96:  MOVLB  01
0B97:  MOVWF  32
0B98:  MOVLW  02
0B99:  MOVWF  33
0B9A:  MOVLP  00
0B9B:  MOVLB  00
0B9C:  CALL   1B2
0B9D:  MOVLP  08
....................                      printf(lcd_putc, "%c%c",4,4);////cactus 
0B9E:  MOVLW  04
0B9F:  MOVLB  01
0BA0:  MOVWF  31
0BA1:  MOVLP  00
0BA2:  MOVLB  00
0BA3:  CALL   1C6
0BA4:  MOVLP  08
0BA5:  MOVLW  04
0BA6:  MOVLB  01
0BA7:  MOVWF  31
0BA8:  MOVLP  00
0BA9:  MOVLB  00
0BAA:  CALL   1C6
0BAB:  MOVLP  08
.................... delay_ms(delay2); 
0BAC:  MOVF   6E,W
0BAD:  MOVLB  01
0BAE:  MOVWF  32
0BAF:  MOVLP  00
0BB0:  MOVLB  00
0BB1:  CALL   050
0BB2:  MOVLP  08
....................                         lcd_gotoxy(cac+2,2);///////borrar 
0BB3:  MOVLW  02
0BB4:  ADDWF  67,W
0BB5:  MOVLB  01
0BB6:  MOVWF  24
0BB7:  MOVLW  00
0BB8:  MOVLB  00
0BB9:  ADDWFC 68,W
0BBA:  MOVLB  01
0BBB:  MOVWF  25
0BBC:  MOVF   24,W
0BBD:  MOVWF  32
0BBE:  MOVLW  02
0BBF:  MOVWF  33
0BC0:  MOVLP  00
0BC1:  MOVLB  00
0BC2:  CALL   1B2
0BC3:  MOVLP  08
....................                      printf(lcd_putc, " "); 
0BC4:  MOVLW  20
0BC5:  MOVLB  01
0BC6:  MOVWF  31
0BC7:  MOVLP  00
0BC8:  MOVLB  00
0BC9:  CALL   1C6
0BCA:  MOVLP  08
.................... }    
....................    
....................      
....................       
....................      lcd_gotoxy(5,1); //apunta a la posicin x=5 y=1 de la LCD 
0BCB:  MOVLW  05
0BCC:  MOVLB  01
0BCD:  MOVWF  32
0BCE:  MOVLW  01
0BCF:  MOVWF  33
0BD0:  MOVLP  00
0BD1:  MOVLB  00
0BD2:  CALL   1B2
0BD3:  MOVLP  08
....................      printf(lcd_putc," P=%3Lu%Lu",final, puntuacion);  //imprime los puntos en la partida 
0BD4:  MOVLW  20
0BD5:  MOVLB  01
0BD6:  MOVWF  31
0BD7:  MOVLP  00
0BD8:  MOVLB  00
0BD9:  CALL   1C6
0BDA:  MOVLP  08
0BDB:  MOVLW  50
0BDC:  MOVLB  01
0BDD:  MOVWF  31
0BDE:  MOVLP  00
0BDF:  MOVLB  00
0BE0:  CALL   1C6
0BE1:  MOVLP  08
0BE2:  MOVLW  3D
0BE3:  MOVLB  01
0BE4:  MOVWF  31
0BE5:  MOVLP  00
0BE6:  MOVLB  00
0BE7:  CALL   1C6
0BE8:  MOVLP  08
0BE9:  MOVLW  02
0BEA:  MOVWF  04
0BEB:  MOVF   62,W
0BEC:  MOVLB  01
0BED:  MOVWF  25
0BEE:  MOVLB  00
0BEF:  MOVF   61,W
0BF0:  MOVLB  01
0BF1:  MOVWF  24
0BF2:  MOVLP  00
0BF3:  MOVLB  00
0BF4:  CALL   2BC
0BF5:  MOVLP  08
0BF6:  MOVLW  10
0BF7:  MOVWF  04
0BF8:  MOVF   60,W
0BF9:  MOVLB  01
0BFA:  MOVWF  25
0BFB:  MOVLB  00
0BFC:  MOVF   5F,W
0BFD:  MOVLB  01
0BFE:  MOVWF  24
0BFF:  MOVLP  00
0C00:  MOVLB  00
0C01:  CALL   2BC
0C02:  MOVLP  08
....................      
....................      lcd_gotoxy(2,2); 
0C03:  MOVLW  02
0C04:  MOVLB  01
0C05:  MOVWF  32
0C06:  MOVWF  33
0C07:  MOVLP  00
0C08:  MOVLB  00
0C09:  CALL   1B2
0C0A:  MOVLP  08
....................      printf(lcd_putc, "%c",1); //imprime dino sin pata izquierda 
0C0B:  MOVLW  01
0C0C:  MOVLB  01
0C0D:  MOVWF  31
0C0E:  MOVLP  00
0C0F:  MOVLB  00
0C10:  CALL   1C6
0C11:  MOVLP  08
....................       lcd_gotoxy(1,1); 
0C12:  MOVLW  01
0C13:  MOVLB  01
0C14:  MOVWF  32
0C15:  MOVWF  33
0C16:  MOVLP  00
0C17:  MOVLB  00
0C18:  CALL   1B2
0C19:  MOVLP  08
....................      printf(lcd_putc, "%c",5); //imprime sol 1  
0C1A:  MOVLW  05
0C1B:  MOVLB  01
0C1C:  MOVWF  31
0C1D:  MOVLP  00
0C1E:  MOVLB  00
0C1F:  CALL   1C6
0C20:  MOVLP  08
....................           
....................      delay_ms(delay1); 
0C21:  MOVF   6D,W
0C22:  MOVLB  01
0C23:  MOVWF  32
0C24:  MOVLP  00
0C25:  MOVLB  00
0C26:  CALL   050
0C27:  MOVLP  08
....................    
....................       lcd_gotoxy(2,2); 
0C28:  MOVLW  02
0C29:  MOVLB  01
0C2A:  MOVWF  32
0C2B:  MOVWF  33
0C2C:  MOVLP  00
0C2D:  MOVLB  00
0C2E:  CALL   1B2
0C2F:  MOVLP  08
....................      printf(lcd_putc, "%c",2); //imprime dino sin pata derecha 
0C30:  MOVLW  02
0C31:  MOVLB  01
0C32:  MOVWF  31
0C33:  MOVLP  00
0C34:  MOVLB  00
0C35:  CALL   1C6
0C36:  MOVLP  08
....................       lcd_gotoxy(1,1); 
0C37:  MOVLW  01
0C38:  MOVLB  01
0C39:  MOVWF  32
0C3A:  MOVWF  33
0C3B:  MOVLP  00
0C3C:  MOVLB  00
0C3D:  CALL   1B2
0C3E:  MOVLP  08
....................      printf(lcd_putc, "%c",6); //imprime sol 2 
0C3F:  MOVLW  06
0C40:  MOVLB  01
0C41:  MOVWF  31
0C42:  MOVLP  00
0C43:  MOVLB  00
0C44:  CALL   1C6
0C45:  MOVLP  08
....................   
....................      delay_ms(delay1); 
0C46:  MOVF   6D,W
0C47:  MOVLB  01
0C48:  MOVWF  32
0C49:  MOVLP  00
0C4A:  MOVLB  00
0C4B:  CALL   050
0C4C:  MOVLP  08
....................      
....................      gua=cac; //antes de entrar al if cuando se preciona el botn, guardamos la variable cac  
0C4D:  MOVF   68,W
0C4E:  MOVWF  6A
0C4F:  MOVF   67,W
0C50:  MOVWF  69
....................       
....................      //////////////////// 
....................        if (input(PIN_B0)==0){  //if cuando se preciona el botn 
0C51:  MOVLB  01
0C52:  BSF    0D.0
0C53:  MOVLB  00
0C54:  BTFSC  0D.0
0C55:  GOTO   6F3
....................           
....................            lcd_putc("\f" ) ; // limpiar pantalla 
0C56:  MOVLW  1F
0C57:  MOVLB  03
0C58:  MOVWF  11
0C59:  MOVLW  00
0C5A:  MOVWF  12
0C5B:  MOVLP  00
0C5C:  MOVLB  00
0C5D:  CALL   200
0C5E:  MOVLP  08
....................             
....................        lcd_gotoxy(5,1);   
0C5F:  MOVLW  05
0C60:  MOVLB  01
0C61:  MOVWF  32
0C62:  MOVLW  01
0C63:  MOVWF  33
0C64:  MOVLP  00
0C65:  MOVLB  00
0C66:  CALL   1B2
0C67:  MOVLP  08
....................      printf(lcd_putc," P=%3Lu%Lu",final, puntuacion);   //imprimir variables final y puntuacin 
0C68:  MOVLW  20
0C69:  MOVLB  01
0C6A:  MOVWF  31
0C6B:  MOVLP  00
0C6C:  MOVLB  00
0C6D:  CALL   1C6
0C6E:  MOVLP  08
0C6F:  MOVLW  50
0C70:  MOVLB  01
0C71:  MOVWF  31
0C72:  MOVLP  00
0C73:  MOVLB  00
0C74:  CALL   1C6
0C75:  MOVLP  08
0C76:  MOVLW  3D
0C77:  MOVLB  01
0C78:  MOVWF  31
0C79:  MOVLP  00
0C7A:  MOVLB  00
0C7B:  CALL   1C6
0C7C:  MOVLP  08
0C7D:  MOVLW  02
0C7E:  MOVWF  04
0C7F:  MOVF   62,W
0C80:  MOVLB  01
0C81:  MOVWF  25
0C82:  MOVLB  00
0C83:  MOVF   61,W
0C84:  MOVLB  01
0C85:  MOVWF  24
0C86:  MOVLP  00
0C87:  MOVLB  00
0C88:  CALL   2BC
0C89:  MOVLP  08
0C8A:  MOVLW  10
0C8B:  MOVWF  04
0C8C:  MOVF   60,W
0C8D:  MOVLB  01
0C8E:  MOVWF  25
0C8F:  MOVLB  00
0C90:  MOVF   5F,W
0C91:  MOVLB  01
0C92:  MOVWF  24
0C93:  MOVLP  00
0C94:  MOVLB  00
0C95:  CALL   2BC
0C96:  MOVLP  08
....................      
....................      lcd_gotoxy(2,1); 
0C97:  MOVLW  02
0C98:  MOVLB  01
0C99:  MOVWF  32
0C9A:  MOVLW  01
0C9B:  MOVWF  33
0C9C:  MOVLP  00
0C9D:  MOVLB  00
0C9E:  CALL   1B2
0C9F:  MOVLP  08
....................      printf(lcd_putc, "%c",0);  //imprime dino completo (saltando) 
0CA0:  MOVLB  01
0CA1:  CLRF   31
0CA2:  MOVLP  00
0CA3:  MOVLB  00
0CA4:  CALL   1C6
0CA5:  MOVLP  08
....................       lcd_gotoxy(1,1); 
0CA6:  MOVLW  01
0CA7:  MOVLB  01
0CA8:  MOVWF  32
0CA9:  MOVWF  33
0CAA:  MOVLP  00
0CAB:  MOVLB  00
0CAC:  CALL   1B2
0CAD:  MOVLP  08
....................      printf(lcd_putc, "%c",5);  //imprime sol 1 
0CAE:  MOVLW  05
0CAF:  MOVLB  01
0CB0:  MOVWF  31
0CB1:  MOVLP  00
0CB2:  MOVLB  00
0CB3:  CALL   1C6
0CB4:  MOVLP  08
....................      delay_ms(5); 
0CB5:  MOVLW  05
0CB6:  MOVLB  01
0CB7:  MOVWF  32
0CB8:  MOVLP  00
0CB9:  MOVLB  00
0CBA:  CALL   050
0CBB:  MOVLP  08
....................    
....................       lcd_gotoxy(2,1); 
0CBC:  MOVLW  02
0CBD:  MOVLB  01
0CBE:  MOVWF  32
0CBF:  MOVLW  01
0CC0:  MOVWF  33
0CC1:  MOVLP  00
0CC2:  MOVLB  00
0CC3:  CALL   1B2
0CC4:  MOVLP  08
....................      printf(lcd_putc, "%c",0); //imprime dino completo (saltando) 
0CC5:  MOVLB  01
0CC6:  CLRF   31
0CC7:  MOVLP  00
0CC8:  MOVLB  00
0CC9:  CALL   1C6
0CCA:  MOVLP  08
....................       lcd_gotoxy(1,1); 
0CCB:  MOVLW  01
0CCC:  MOVLB  01
0CCD:  MOVWF  32
0CCE:  MOVWF  33
0CCF:  MOVLP  00
0CD0:  MOVLB  00
0CD1:  CALL   1B2
0CD2:  MOVLP  08
....................      printf(lcd_putc, "%c",6); //imprime sol 2 
0CD3:  MOVLW  06
0CD4:  MOVLB  01
0CD5:  MOVWF  31
0CD6:  MOVLP  00
0CD7:  MOVLB  00
0CD8:  CALL   1C6
0CD9:  MOVLP  08
....................      delay_ms(5);     
0CDA:  MOVLW  05
0CDB:  MOVLB  01
0CDC:  MOVWF  32
0CDD:  MOVLP  00
0CDE:  MOVLB  00
0CDF:  CALL   050
0CE0:  MOVLP  08
....................      int lo; 
....................    lo= cac-4;  // 
0CE1:  MOVLW  04
0CE2:  SUBWF  67,W
0CE3:  MOVWF  77
0CE4:  MOVLW  00
0CE5:  SUBWFC 68,W
0CE6:  MOVWF  7A
0CE7:  MOVF   77,W
0CE8:  MOVLB  01
0CE9:  MOVWF  22
....................    output_high (PIN_B3); //sonar cuando saltan 
0CEA:  BCF    0D.3
0CEB:  MOVLB  02
0CEC:  BSF    0D.3
....................      delay_ms(5);   
0CED:  MOVLW  05
0CEE:  MOVLB  01
0CEF:  MOVWF  32
0CF0:  MOVLP  00
0CF1:  MOVLB  00
0CF2:  CALL   050
0CF3:  MOVLP  08
....................         output_low (PIN_B3); //apagar bocina 
0CF4:  MOVLB  01
0CF5:  BCF    0D.3
0CF6:  MOVLB  02
0CF7:  BCF    0D.3
....................          
....................     
....................  
....................          
....................  for (cac=gua-1; gua>lo; gua--){///ciclo para mover cactus y dino saltando  
0CF8:  MOVLW  01
0CF9:  MOVLB  00
0CFA:  SUBWF  69,W
0CFB:  MOVWF  67
0CFC:  MOVLW  00
0CFD:  SUBWFC 6A,W
0CFE:  MOVWF  68
0CFF:  BTFSC  6A.7
0D00:  GOTO   6EA
0D01:  MOVF   6A,F
0D02:  BTFSS  03.2
0D03:  GOTO   50C
0D04:  MOVF   69,W
0D05:  MOVLB  01
0D06:  SUBWF  22,W
0D07:  BTFSS  03.0
0D08:  GOTO   50B
0D09:  MOVLB  00
0D0A:  GOTO   6EA
0D0B:  MOVLB  00
....................     
....................                 puntuacion=guar;  
0D0C:  CLRF   60
0D0D:  MOVF   6B,W
0D0E:  MOVWF  5F
....................               guar++; 
0D0F:  INCF   6B,F
....................               lcd_gotoxy(5,1); 
0D10:  MOVLW  05
0D11:  MOVLB  01
0D12:  MOVWF  32
0D13:  MOVLW  01
0D14:  MOVWF  33
0D15:  MOVLP  00
0D16:  MOVLB  00
0D17:  CALL   1B2
0D18:  MOVLP  08
....................               
....................                 printf(lcd_putc," P=%3Lu%Lu",final, puntuacion);  
0D19:  MOVLW  20
0D1A:  MOVLB  01
0D1B:  MOVWF  31
0D1C:  MOVLP  00
0D1D:  MOVLB  00
0D1E:  CALL   1C6
0D1F:  MOVLP  08
0D20:  MOVLW  50
0D21:  MOVLB  01
0D22:  MOVWF  31
0D23:  MOVLP  00
0D24:  MOVLB  00
0D25:  CALL   1C6
0D26:  MOVLP  08
0D27:  MOVLW  3D
0D28:  MOVLB  01
0D29:  MOVWF  31
0D2A:  MOVLP  00
0D2B:  MOVLB  00
0D2C:  CALL   1C6
0D2D:  MOVLP  08
0D2E:  MOVLW  02
0D2F:  MOVWF  04
0D30:  MOVF   62,W
0D31:  MOVLB  01
0D32:  MOVWF  25
0D33:  MOVLB  00
0D34:  MOVF   61,W
0D35:  MOVLB  01
0D36:  MOVWF  24
0D37:  MOVLP  00
0D38:  MOVLB  00
0D39:  CALL   2BC
0D3A:  MOVLP  08
0D3B:  MOVLW  10
0D3C:  MOVWF  04
0D3D:  MOVF   60,W
0D3E:  MOVLB  01
0D3F:  MOVWF  25
0D40:  MOVLB  00
0D41:  MOVF   5F,W
0D42:  MOVLB  01
0D43:  MOVWF  24
0D44:  MOVLP  00
0D45:  MOVLB  00
0D46:  CALL   2BC
0D47:  MOVLP  08
....................  
....................   if (randon==0){ 
0D48:  MOVF   5E,F
0D49:  BTFSS  03.2
0D4A:  GOTO   57A
....................      lcd_gotoxy(gua,2); 
0D4B:  MOVF   69,W
0D4C:  MOVLB  01
0D4D:  MOVWF  32
0D4E:  MOVLW  02
0D4F:  MOVWF  33
0D50:  MOVLP  00
0D51:  MOVLB  00
0D52:  CALL   1B2
0D53:  MOVLP  08
....................                      printf(lcd_putc, "%c",4);////cactus 
0D54:  MOVLW  04
0D55:  MOVLB  01
0D56:  MOVWF  31
0D57:  MOVLP  00
0D58:  MOVLB  00
0D59:  CALL   1C6
0D5A:  MOVLP  08
....................    //delay_ms(delay2); 
....................                         lcd_gotoxy(gua+1,2);///////borrar 
0D5B:  MOVLW  01
0D5C:  ADDWF  69,W
0D5D:  MOVLB  01
0D5E:  MOVWF  24
0D5F:  MOVLW  00
0D60:  MOVLB  00
0D61:  ADDWFC 6A,W
0D62:  MOVLB  01
0D63:  MOVWF  25
0D64:  MOVF   24,W
0D65:  MOVWF  32
0D66:  MOVLW  02
0D67:  MOVWF  33
0D68:  MOVLP  00
0D69:  MOVLB  00
0D6A:  CALL   1B2
0D6B:  MOVLP  08
....................                      printf(lcd_putc, " "); 
0D6C:  MOVLW  20
0D6D:  MOVLB  01
0D6E:  MOVWF  31
0D6F:  MOVLP  00
0D70:  MOVLB  00
0D71:  CALL   1C6
0D72:  MOVLP  08
....................                     delay_ms(delay); 
0D73:  MOVF   6C,W
0D74:  MOVLB  01
0D75:  MOVWF  32
0D76:  MOVLP  00
0D77:  MOVLB  00
0D78:  CALL   050
0D79:  MOVLP  08
.................... } 
....................  
....................  
.................... if (randon==1){ 
0D7A:  DECFSZ 5E,W
0D7B:  GOTO   5AB
....................      lcd_gotoxy(gua,2); 
0D7C:  MOVF   69,W
0D7D:  MOVLB  01
0D7E:  MOVWF  32
0D7F:  MOVLW  02
0D80:  MOVWF  33
0D81:  MOVLP  00
0D82:  MOVLB  00
0D83:  CALL   1B2
0D84:  MOVLP  08
....................                      printf(lcd_putc, "%c",3);////cactus 
0D85:  MOVLW  03
0D86:  MOVLB  01
0D87:  MOVWF  31
0D88:  MOVLP  00
0D89:  MOVLB  00
0D8A:  CALL   1C6
0D8B:  MOVLP  08
....................   //delay_ms(delay2); 
....................                         lcd_gotoxy(gua+1,2);///////borrar 
0D8C:  MOVLW  01
0D8D:  ADDWF  69,W
0D8E:  MOVLB  01
0D8F:  MOVWF  24
0D90:  MOVLW  00
0D91:  MOVLB  00
0D92:  ADDWFC 6A,W
0D93:  MOVLB  01
0D94:  MOVWF  25
0D95:  MOVF   24,W
0D96:  MOVWF  32
0D97:  MOVLW  02
0D98:  MOVWF  33
0D99:  MOVLP  00
0D9A:  MOVLB  00
0D9B:  CALL   1B2
0D9C:  MOVLP  08
....................                      printf(lcd_putc, " "); 
0D9D:  MOVLW  20
0D9E:  MOVLB  01
0D9F:  MOVWF  31
0DA0:  MOVLP  00
0DA1:  MOVLB  00
0DA2:  CALL   1C6
0DA3:  MOVLP  08
....................                      delay_ms(delay); 
0DA4:  MOVF   6C,W
0DA5:  MOVLB  01
0DA6:  MOVWF  32
0DA7:  MOVLP  00
0DA8:  MOVLB  00
0DA9:  CALL   050
0DAA:  MOVLP  08
.................... } 
....................  
.................... if (randon==2){ 
0DAB:  MOVF   5E,W
0DAC:  SUBLW  02
0DAD:  BTFSS  03.2
0DAE:  GOTO   5E5
....................      lcd_gotoxy(gua,2); 
0DAF:  MOVF   69,W
0DB0:  MOVLB  01
0DB1:  MOVWF  32
0DB2:  MOVLW  02
0DB3:  MOVWF  33
0DB4:  MOVLP  00
0DB5:  MOVLB  00
0DB6:  CALL   1B2
0DB7:  MOVLP  08
....................                      printf(lcd_putc, "%c%c",4,3);////cactus 
0DB8:  MOVLW  04
0DB9:  MOVLB  01
0DBA:  MOVWF  31
0DBB:  MOVLP  00
0DBC:  MOVLB  00
0DBD:  CALL   1C6
0DBE:  MOVLP  08
0DBF:  MOVLW  03
0DC0:  MOVLB  01
0DC1:  MOVWF  31
0DC2:  MOVLP  00
0DC3:  MOVLB  00
0DC4:  CALL   1C6
0DC5:  MOVLP  08
....................  // delay_ms(delay2); 
....................                         lcd_gotoxy(gua+2,2);///////borrar 
0DC6:  MOVLW  02
0DC7:  ADDWF  69,W
0DC8:  MOVLB  01
0DC9:  MOVWF  24
0DCA:  MOVLW  00
0DCB:  MOVLB  00
0DCC:  ADDWFC 6A,W
0DCD:  MOVLB  01
0DCE:  MOVWF  25
0DCF:  MOVF   24,W
0DD0:  MOVWF  32
0DD1:  MOVLW  02
0DD2:  MOVWF  33
0DD3:  MOVLP  00
0DD4:  MOVLB  00
0DD5:  CALL   1B2
0DD6:  MOVLP  08
....................                      printf(lcd_putc, " "); 
0DD7:  MOVLW  20
0DD8:  MOVLB  01
0DD9:  MOVWF  31
0DDA:  MOVLP  00
0DDB:  MOVLB  00
0DDC:  CALL   1C6
0DDD:  MOVLP  08
....................                     delay_ms(delay); 
0DDE:  MOVF   6C,W
0DDF:  MOVLB  01
0DE0:  MOVWF  32
0DE1:  MOVLP  00
0DE2:  MOVLB  00
0DE3:  CALL   050
0DE4:  MOVLP  08
.................... } 
....................  
.................... if (randon==3){ 
0DE5:  MOVF   5E,W
0DE6:  SUBLW  03
0DE7:  BTFSS  03.2
0DE8:  GOTO   61F
....................      lcd_gotoxy(gua,2); 
0DE9:  MOVF   69,W
0DEA:  MOVLB  01
0DEB:  MOVWF  32
0DEC:  MOVLW  02
0DED:  MOVWF  33
0DEE:  MOVLP  00
0DEF:  MOVLB  00
0DF0:  CALL   1B2
0DF1:  MOVLP  08
....................                      printf(lcd_putc, "%c%c",3,4);////cactus 
0DF2:  MOVLW  03
0DF3:  MOVLB  01
0DF4:  MOVWF  31
0DF5:  MOVLP  00
0DF6:  MOVLB  00
0DF7:  CALL   1C6
0DF8:  MOVLP  08
0DF9:  MOVLW  04
0DFA:  MOVLB  01
0DFB:  MOVWF  31
0DFC:  MOVLP  00
0DFD:  MOVLB  00
0DFE:  CALL   1C6
0DFF:  MOVLP  08
....................   //delay_ms(delay2); 
....................                         lcd_gotoxy(gua+2,2);///////borrar 
0E00:  MOVLW  02
0E01:  ADDWF  69,W
0E02:  MOVLB  01
0E03:  MOVWF  24
0E04:  MOVLW  00
0E05:  MOVLB  00
0E06:  ADDWFC 6A,W
0E07:  MOVLB  01
0E08:  MOVWF  25
0E09:  MOVF   24,W
0E0A:  MOVWF  32
0E0B:  MOVLW  02
0E0C:  MOVWF  33
0E0D:  MOVLP  00
0E0E:  MOVLB  00
0E0F:  CALL   1B2
0E10:  MOVLP  08
....................                      printf(lcd_putc, " "); 
0E11:  MOVLW  20
0E12:  MOVLB  01
0E13:  MOVWF  31
0E14:  MOVLP  00
0E15:  MOVLB  00
0E16:  CALL   1C6
0E17:  MOVLP  08
....................                      delay_ms(delay); 
0E18:  MOVF   6C,W
0E19:  MOVLB  01
0E1A:  MOVWF  32
0E1B:  MOVLP  00
0E1C:  MOVLB  00
0E1D:  CALL   050
0E1E:  MOVLP  08
.................... } 
.................... if (randon==4){ 
0E1F:  MOVF   5E,W
0E20:  SUBLW  04
0E21:  BTFSS  03.2
0E22:  GOTO   660
....................      lcd_gotoxy(gua,2); 
0E23:  MOVF   69,W
0E24:  MOVLB  01
0E25:  MOVWF  32
0E26:  MOVLW  02
0E27:  MOVWF  33
0E28:  MOVLP  00
0E29:  MOVLB  00
0E2A:  CALL   1B2
0E2B:  MOVLP  08
....................                      printf(lcd_putc, "%c%c%c",4,3,4);////cactus 
0E2C:  MOVLW  04
0E2D:  MOVLB  01
0E2E:  MOVWF  31
0E2F:  MOVLP  00
0E30:  MOVLB  00
0E31:  CALL   1C6
0E32:  MOVLP  08
0E33:  MOVLW  03
0E34:  MOVLB  01
0E35:  MOVWF  31
0E36:  MOVLP  00
0E37:  MOVLB  00
0E38:  CALL   1C6
0E39:  MOVLP  08
0E3A:  MOVLW  04
0E3B:  MOVLB  01
0E3C:  MOVWF  31
0E3D:  MOVLP  00
0E3E:  MOVLB  00
0E3F:  CALL   1C6
0E40:  MOVLP  08
.................... //  delay_ms(delay2); 
....................                         lcd_gotoxy(gua+3,2);///////borrar 
0E41:  MOVLW  03
0E42:  ADDWF  69,W
0E43:  MOVLB  01
0E44:  MOVWF  24
0E45:  MOVLW  00
0E46:  MOVLB  00
0E47:  ADDWFC 6A,W
0E48:  MOVLB  01
0E49:  MOVWF  25
0E4A:  MOVF   24,W
0E4B:  MOVWF  32
0E4C:  MOVLW  02
0E4D:  MOVWF  33
0E4E:  MOVLP  00
0E4F:  MOVLB  00
0E50:  CALL   1B2
0E51:  MOVLP  08
....................                      printf(lcd_putc, " "); 
0E52:  MOVLW  20
0E53:  MOVLB  01
0E54:  MOVWF  31
0E55:  MOVLP  00
0E56:  MOVLB  00
0E57:  CALL   1C6
0E58:  MOVLP  08
....................                    delay_ms(delay); 
0E59:  MOVF   6C,W
0E5A:  MOVLB  01
0E5B:  MOVWF  32
0E5C:  MOVLP  00
0E5D:  MOVLB  00
0E5E:  CALL   050
0E5F:  MOVLP  08
.................... } 
....................  
.................... if (randon==5){ 
0E60:  MOVF   5E,W
0E61:  SUBLW  05
0E62:  BTFSS  03.2
0E63:  GOTO   6A1
....................      lcd_gotoxy(gua,2); 
0E64:  MOVF   69,W
0E65:  MOVLB  01
0E66:  MOVWF  32
0E67:  MOVLW  02
0E68:  MOVWF  33
0E69:  MOVLP  00
0E6A:  MOVLB  00
0E6B:  CALL   1B2
0E6C:  MOVLP  08
....................                      printf(lcd_putc, "%c%c%c",3,4,3);////cactus 
0E6D:  MOVLW  03
0E6E:  MOVLB  01
0E6F:  MOVWF  31
0E70:  MOVLP  00
0E71:  MOVLB  00
0E72:  CALL   1C6
0E73:  MOVLP  08
0E74:  MOVLW  04
0E75:  MOVLB  01
0E76:  MOVWF  31
0E77:  MOVLP  00
0E78:  MOVLB  00
0E79:  CALL   1C6
0E7A:  MOVLP  08
0E7B:  MOVLW  03
0E7C:  MOVLB  01
0E7D:  MOVWF  31
0E7E:  MOVLP  00
0E7F:  MOVLB  00
0E80:  CALL   1C6
0E81:  MOVLP  08
....................   //delay_ms(delay2); 
....................                         lcd_gotoxy(gua+3,2);///////borrar 
0E82:  MOVLW  03
0E83:  ADDWF  69,W
0E84:  MOVLB  01
0E85:  MOVWF  24
0E86:  MOVLW  00
0E87:  MOVLB  00
0E88:  ADDWFC 6A,W
0E89:  MOVLB  01
0E8A:  MOVWF  25
0E8B:  MOVF   24,W
0E8C:  MOVWF  32
0E8D:  MOVLW  02
0E8E:  MOVWF  33
0E8F:  MOVLP  00
0E90:  MOVLB  00
0E91:  CALL   1B2
0E92:  MOVLP  08
....................                      printf(lcd_putc, " "); 
0E93:  MOVLW  20
0E94:  MOVLB  01
0E95:  MOVWF  31
0E96:  MOVLP  00
0E97:  MOVLB  00
0E98:  CALL   1C6
0E99:  MOVLP  08
....................                     delay_ms(delay); 
0E9A:  MOVF   6C,W
0E9B:  MOVLB  01
0E9C:  MOVWF  32
0E9D:  MOVLP  00
0E9E:  MOVLB  00
0E9F:  CALL   050
0EA0:  MOVLP  08
.................... } 
.................... if (randon==6){ 
0EA1:  MOVF   5E,W
0EA2:  SUBLW  06
0EA3:  BTFSS  03.2
0EA4:  GOTO   6DB
....................      lcd_gotoxy(gua,2); 
0EA5:  MOVF   69,W
0EA6:  MOVLB  01
0EA7:  MOVWF  32
0EA8:  MOVLW  02
0EA9:  MOVWF  33
0EAA:  MOVLP  00
0EAB:  MOVLB  00
0EAC:  CALL   1B2
0EAD:  MOVLP  08
....................                      printf(lcd_putc, "%c%c",4,4);////cactus 
0EAE:  MOVLW  04
0EAF:  MOVLB  01
0EB0:  MOVWF  31
0EB1:  MOVLP  00
0EB2:  MOVLB  00
0EB3:  CALL   1C6
0EB4:  MOVLP  08
0EB5:  MOVLW  04
0EB6:  MOVLB  01
0EB7:  MOVWF  31
0EB8:  MOVLP  00
0EB9:  MOVLB  00
0EBA:  CALL   1C6
0EBB:  MOVLP  08
....................  
....................                         lcd_gotoxy(gua+2,2);///////borrar 
0EBC:  MOVLW  02
0EBD:  ADDWF  69,W
0EBE:  MOVLB  01
0EBF:  MOVWF  24
0EC0:  MOVLW  00
0EC1:  MOVLB  00
0EC2:  ADDWFC 6A,W
0EC3:  MOVLB  01
0EC4:  MOVWF  25
0EC5:  MOVF   24,W
0EC6:  MOVWF  32
0EC7:  MOVLW  02
0EC8:  MOVWF  33
0EC9:  MOVLP  00
0ECA:  MOVLB  00
0ECB:  CALL   1B2
0ECC:  MOVLP  08
....................                      printf(lcd_putc, " "); 
0ECD:  MOVLW  20
0ECE:  MOVLB  01
0ECF:  MOVWF  31
0ED0:  MOVLP  00
0ED1:  MOVLB  00
0ED2:  CALL   1C6
0ED3:  MOVLP  08
....................                      delay_ms(delay); 
0ED4:  MOVF   6C,W
0ED5:  MOVLB  01
0ED6:  MOVWF  32
0ED7:  MOVLP  00
0ED8:  MOVLB  00
0ED9:  CALL   050
0EDA:  MOVLP  08
.................... }   
....................  
....................            
....................                                          if(guar>=9) //solo va del 0 al 9 
0EDB:  MOVF   6B,W
0EDC:  SUBLW  08
0EDD:  BTFSC  03.0
0EDE:  GOTO   6E4
....................                                             { 
....................                                      final++; //cuando las unidades son 9, sumamos a las decenas 
0EDF:  INCF   61,F
0EE0:  BTFSC  03.2
0EE1:  INCF   62,F
....................                                          guar=0; //regresamos a 0 
0EE2:  CLRF   6B
....................                                         } 
0EE3:  GOTO   6E5
....................                                         else{ 
....................                                     guar++; 
0EE4:  INCF   6B,F
....................          
....................                                         } 
0EE5:  MOVF   69,W
0EE6:  BTFSC  03.2
0EE7:  DECF   6A,F
0EE8:  DECF   69,F
0EE9:  GOTO   4FF
....................           ///&&&& 
....................            } 
....................   
....................          lcd_putc("\f" ) ; 
0EEA:  MOVLW  20
0EEB:  MOVLB  03
0EEC:  MOVWF  11
0EED:  MOVLW  00
0EEE:  MOVWF  12
0EEF:  MOVLP  00
0EF0:  MOVLB  00
0EF1:  CALL   200
0EF2:  MOVLP  08
....................            
....................  } 
....................      cac=gua; 
0EF3:  MOVF   6A,W
0EF4:  MOVWF  68
0EF5:  MOVF   69,W
0EF6:  MOVWF  67
....................       
....................   
....................     
....................      
....................     if(puntuacion>=9) 
0EF7:  MOVF   60,F
0EF8:  BTFSS  03.2
0EF9:  GOTO   6FE
0EFA:  MOVF   5F,W
0EFB:  SUBLW  08
0EFC:  BTFSC  03.0
0EFD:  GOTO   704
....................     { 
....................      final++; 
0EFE:  INCF   61,F
0EFF:  BTFSC  03.2
0F00:  INCF   62,F
....................      puntuacion=0; 
0F01:  CLRF   60
0F02:  CLRF   5F
....................     } 
0F03:  GOTO   707
....................     else{ 
....................         puntuacion++; 
0F04:  INCF   5F,F
0F05:  BTFSC  03.2
0F06:  INCF   60,F
....................          
....................     } 
....................       guar=puntuacion; 
0F07:  MOVF   5F,W
0F08:  MOVWF  6B
0F09:  MOVF   67,W
0F0A:  BTFSC  03.2
0F0B:  DECF   68,F
0F0C:  DECF   67,F
0F0D:  GOTO   003
.................... } 
0F0E:  MOVLP  00
0F0F:  GOTO   535 (RETURN)
.................... } 
....................  
.................... //////////////////////// 
....................  
....................  
....................  
....................  
....................  
.................... void main(){   //main 
*
034C:  CLRF   60
034D:  CLRF   5F
034E:  CLRF   62
034F:  CLRF   61
0350:  CLRF   64
0351:  CLRF   63
0352:  CLRF   66
0353:  CLRF   65
0354:  CLRF   6B
0355:  CLRF   6C
0356:  CLRF   6D
0357:  CLRF   6E
0358:  MOVLB  01
0359:  CLRF   21
035A:  CLRF   20
035B:  MOVLB  0F
035C:  CLRF   11
035D:  CLRF   12
035E:  CLRF   18
035F:  CLRF   19
0360:  CLRF   1A
0361:  MOVLB  03
0362:  CLRF   0C
0363:  CLRF   0D
0364:  CLRF   0F
0365:  CLRF   10
0366:  MOVLB  02
0367:  CLRF   12
0368:  CLRF   11
0369:  CLRF   14
036A:  CLRF   13
036B:  GOTO   3AD
036C:  DATA 02,34
036D:  DATA 00,34
036E:  DATA 20,34
036F:  DATA 00,34
0370:  DATA 00,34
0371:  DATA 38,34
0372:  DATA 00,34
0373:  DATA 26,34
0374:  DATA 07,34
0375:  DATA 17,34
0376:  DATA 16,34
0377:  DATA 1F,34
0378:  DATA 0E,34
0379:  DATA 0A,34
037A:  DATA 0F,34
037B:  DATA 00,34
037C:  DATA 07,34
037D:  DATA 17,34
037E:  DATA 16,34
037F:  DATA 1F,34
0380:  DATA 0E,34
0381:  DATA 02,34
0382:  DATA 03,34
0383:  DATA 00,34
0384:  DATA 07,34
0385:  DATA 17,34
0386:  DATA 16,34
0387:  DATA 1F,34
0388:  DATA 0E,34
0389:  DATA 08,34
038A:  DATA 0C,34
038B:  DATA 00,34
038C:  DATA 06,34
038D:  DATA 16,34
038E:  DATA 16,34
038F:  DATA 1E,34
0390:  DATA 1E,34
0391:  DATA 06,34
0392:  DATA 06,34
0393:  DATA 1F,34
0394:  DATA 00,34
0395:  DATA 00,34
0396:  DATA 0C,34
0397:  DATA 0D,34
0398:  DATA 0F,34
0399:  DATA 0C,34
039A:  DATA 0C,34
039B:  DATA 1F,34
039C:  DATA 1D,34
039D:  DATA 1C,34
039E:  DATA 19,34
039F:  DATA 02,34
03A0:  DATA 14,34
03A1:  DATA 00,34
03A2:  DATA 00,34
03A3:  DATA 00,34
03A4:  DATA 1C,34
03A5:  DATA 1D,34
03A6:  DATA 18,34
03A7:  DATA 02,34
03A8:  DATA 08,34
03A9:  DATA 00,34
03AA:  DATA 00,34
03AB:  DATA 00,34
03AC:  DATA 00,34
03AD:  MOVLW  03
03AE:  MOVWF  05
03AF:  MOVLW  6C
03B0:  MOVWF  04
03B1:  BSF    05.7
03B2:  MOVIW  [FSR0++],W
03B3:  MOVWF  77
03B4:  XORLW  00
03B5:  BTFSC  03.2
03B6:  GOTO   3C7
03B7:  MOVIW  [FSR0++],W
03B8:  MOVWF  78
03B9:  BTFSC  78.7
03BA:  GOTO   3BF
03BB:  ANDLW  0F
03BC:  MOVWF  07
03BD:  MOVIW  [FSR0++],W
03BE:  MOVWF  06
03BF:  BTFSC  78.6
03C0:  MOVIW  [FSR0++],W
03C1:  BTFSS  78.6
03C2:  MOVIW  [FSR0++],W
03C3:  MOVWI  W,[FSR1++]
03C4:  DECFSZ 77,F
03C5:  GOTO   3C1
03C6:  GOTO   3B2
....................     output_high (PIN_D7); //alimentamos LCD 
03C7:  MOVLB  01
03C8:  BCF    0F.7
03C9:  MOVLB  02
03CA:  BSF    0F.7
....................     lcd_init(); //iniciamos LCD 
03CB:  MOVLB  00
03CC:  GOTO   130
.................... lcd_set_cgram_char(0, character1); //guardamos caracteres personalizados en cgram 
03CD:  MOVLB  01
03CE:  CLRF   22
03CF:  MOVLW  20
03D0:  MOVWF  24
03D1:  MOVLW  06
03D2:  MOVWF  23
03D3:  MOVLB  00
03D4:  CALL   186
.................... lcd_set_cgram_char(1, character2); 
03D5:  MOVLW  01
03D6:  MOVLB  01
03D7:  MOVWF  22
03D8:  MOVLW  20
03D9:  MOVWF  24
03DA:  MOVLW  0E
03DB:  MOVWF  23
03DC:  MOVLB  00
03DD:  CALL   186
.................... lcd_set_cgram_char(2, character3); 
03DE:  MOVLW  02
03DF:  MOVLB  01
03E0:  MOVWF  22
03E1:  MOVLW  20
03E2:  MOVWF  24
03E3:  MOVLW  16
03E4:  MOVWF  23
03E5:  MOVLB  00
03E6:  CALL   186
.................... lcd_set_cgram_char(3, character4); 
03E7:  MOVLW  03
03E8:  MOVLB  01
03E9:  MOVWF  22
03EA:  MOVLW  20
03EB:  MOVWF  24
03EC:  MOVLW  1E
03ED:  MOVWF  23
03EE:  MOVLB  00
03EF:  CALL   186
.................... lcd_set_cgram_char(4, character5); 
03F0:  MOVLW  04
03F1:  MOVLB  01
03F2:  MOVWF  22
03F3:  MOVLW  20
03F4:  MOVWF  24
03F5:  MOVLW  26
03F6:  MOVWF  23
03F7:  MOVLB  00
03F8:  CALL   186
.................... lcd_set_cgram_char(5, character6); 
03F9:  MOVLW  05
03FA:  MOVLB  01
03FB:  MOVWF  22
03FC:  MOVLW  20
03FD:  MOVWF  24
03FE:  MOVLW  2E
03FF:  MOVWF  23
0400:  MOVLB  00
0401:  CALL   186
.................... lcd_set_cgram_char(6, character7); 
0402:  MOVLW  06
0403:  MOVLB  01
0404:  MOVWF  22
0405:  MOVLW  20
0406:  MOVWF  24
0407:  MOVLW  36
0408:  MOVWF  23
0409:  MOVLB  00
040A:  CALL   186
....................  
....................    set_tris_b(0x00);//configura puerto b 
040B:  MOVLW  00
040C:  MOVLB  01
040D:  MOVWF  0D
....................    output_b(0x00); 
040E:  CLRF   0D
040F:  MOVLB  02
0410:  CLRF   0D
....................  
....................    
....................     
....................   while (input(PIN_B0)==1){   ////mensaje de bienvenida mientras no se precione B0  
0411:  MOVLB  01
0412:  BSF    0D.0
0413:  MOVLB  00
0414:  BTFSS  0D.0
0415:  GOTO   434
....................       
....................         lcd_gotoxy(1,1); 
0416:  MOVLW  01
0417:  MOVLB  01
0418:  MOVWF  32
0419:  MOVWF  33
041A:  MOVLB  00
041B:  CALL   1B2
....................       printf(lcd_putc,"Presiona A"); 
041C:  MOVLW  21
041D:  MOVLB  03
041E:  MOVWF  11
041F:  MOVLW  00
0420:  MOVWF  12
0421:  MOVLB  00
0422:  CALL   200
....................       lcd_gotoxy(1,2); 
0423:  MOVLW  01
0424:  MOVLB  01
0425:  MOVWF  32
0426:  MOVLW  02
0427:  MOVWF  33
0428:  MOVLB  00
0429:  CALL   1B2
....................       printf(lcd_putc,"Para comenzar"); 
042A:  MOVLW  27
042B:  MOVLB  03
042C:  MOVWF  11
042D:  MOVLW  00
042E:  MOVWF  12
042F:  MOVLB  00
0430:  CALL   200
0431:  MOVLB  02
0432:  GOTO   411
0433:  MOVLB  00
....................   } 
....................  
....................  
....................    delay_ms(100);  
0434:  MOVLW  64
0435:  MOVLB  01
0436:  MOVWF  32
0437:  MOVLB  00
0438:  CALL   050
....................    
....................    lcd_putc("\f" ) ; //limpia la pantalla 
0439:  MOVLW  2E
043A:  MOVLB  03
043B:  MOVWF  11
043C:  MOVLW  00
043D:  MOVWF  12
043E:  MOVLB  00
043F:  CALL   200
....................     
....................        lcd_gotoxy(1,1); 
0440:  MOVLW  01
0441:  MOVLB  01
0442:  MOVWF  32
0443:  MOVWF  33
0444:  MOVLB  00
0445:  CALL   1B2
....................       printf(lcd_putc,"Presentado por:"); 
0446:  MOVLW  2F
0447:  MOVLB  03
0448:  MOVWF  11
0449:  MOVLW  00
044A:  MOVWF  12
044B:  MOVLB  00
044C:  CALL   200
....................       lcd_gotoxy(1,2); 
044D:  MOVLW  01
044E:  MOVLB  01
044F:  MOVWF  32
0450:  MOVLW  02
0451:  MOVWF  33
0452:  MOVLB  00
0453:  CALL   1B2
....................       printf(lcd_putc,"Jesus Fer Hiram"); 
0454:  MOVLW  37
0455:  MOVLB  03
0456:  MOVWF  11
0457:  MOVLW  00
0458:  MOVWF  12
0459:  MOVLB  00
045A:  CALL   200
....................       delay_ms(500); 
045B:  MOVLW  02
045C:  MOVLB  01
045D:  MOVWF  22
045E:  MOVLW  FA
045F:  MOVWF  32
0460:  MOVLB  00
0461:  CALL   050
0462:  MOVLB  01
0463:  DECFSZ 22,F
0464:  GOTO   45E
....................          lcd_putc("\f" ) ; 
0465:  MOVLW  3F
0466:  MOVLB  03
0467:  MOVWF  11
0468:  MOVLW  00
0469:  MOVWF  12
046A:  MOVLB  00
046B:  CALL   200
....................        
....................       
....................       lcd_gotoxy(4,1); 
046C:  MOVLW  04
046D:  MOVLB  01
046E:  MOVWF  32
046F:  MOVLW  01
0470:  MOVWF  33
0471:  MOVLB  00
0472:  CALL   1B2
....................     printf(lcd_putc," LISTO !"); 
0473:  MOVLW  40
0474:  CLRF   05
0475:  MOVWF  04
0476:  MOVLW  80
0477:  MOVWF  05
0478:  GOTO   24E
....................       delay_ms(100); 
0479:  MOVLW  64
047A:  MOVLB  01
047B:  MOVWF  32
047C:  MOVLB  00
047D:  CALL   050
....................     lcd_putc("\f" ) ; 
047E:  MOVLW  4B
047F:  MOVLB  03
0480:  MOVWF  11
0481:  MOVLW  00
0482:  MOVWF  12
0483:  MOVLB  00
0484:  CALL   200
....................       
....................      
....................      
....................         output_high (PIN_B3); 
0485:  MOVLB  01
0486:  BCF    0D.3
0487:  MOVLB  02
0488:  BSF    0D.3
....................      delay_ms(5);   
0489:  MOVLW  05
048A:  MOVLB  01
048B:  MOVWF  32
048C:  MOVLB  00
048D:  CALL   050
....................         output_low (PIN_B3); 
048E:  MOVLB  01
048F:  BCF    0D.3
0490:  MOVLB  02
0491:  BCF    0D.3
....................          delay_ms(5);  
0492:  MOVLW  05
0493:  MOVLB  01
0494:  MOVWF  32
0495:  MOVLB  00
0496:  CALL   050
....................       lcd_gotoxy(8,1); 
0497:  MOVLW  08
0498:  MOVLB  01
0499:  MOVWF  32
049A:  MOVLW  01
049B:  MOVWF  33
049C:  MOVLB  00
049D:  CALL   1B2
....................       printf(lcd_putc," 3 "); 
049E:  MOVLW  20
049F:  MOVLB  01
04A0:  MOVWF  31
04A1:  MOVLB  00
04A2:  CALL   1C6
04A3:  MOVLW  33
04A4:  MOVLB  01
04A5:  MOVWF  31
04A6:  MOVLB  00
04A7:  CALL   1C6
04A8:  MOVLW  20
04A9:  MOVLB  01
04AA:  MOVWF  31
04AB:  MOVLB  00
04AC:  CALL   1C6
....................         delay_ms(100);  
04AD:  MOVLW  64
04AE:  MOVLB  01
04AF:  MOVWF  32
04B0:  MOVLB  00
04B1:  CALL   050
....................     lcd_putc("\f" ) ; 
04B2:  MOVLW  4C
04B3:  MOVLB  03
04B4:  MOVWF  11
04B5:  MOVLW  00
04B6:  MOVWF  12
04B7:  MOVLB  00
04B8:  CALL   200
....................  
....................       
....................         output_high (PIN_B3); 
04B9:  MOVLB  01
04BA:  BCF    0D.3
04BB:  MOVLB  02
04BC:  BSF    0D.3
....................      delay_ms(5);   
04BD:  MOVLW  05
04BE:  MOVLB  01
04BF:  MOVWF  32
04C0:  MOVLB  00
04C1:  CALL   050
....................         output_low (PIN_B3); 
04C2:  MOVLB  01
04C3:  BCF    0D.3
04C4:  MOVLB  02
04C5:  BCF    0D.3
....................          delay_ms(5);  
04C6:  MOVLW  05
04C7:  MOVLB  01
04C8:  MOVWF  32
04C9:  MOVLB  00
04CA:  CALL   050
....................          lcd_gotoxy(8,1); 
04CB:  MOVLW  08
04CC:  MOVLB  01
04CD:  MOVWF  32
04CE:  MOVLW  01
04CF:  MOVWF  33
04D0:  MOVLB  00
04D1:  CALL   1B2
....................          printf(lcd_putc," 2 "); 
04D2:  MOVLW  20
04D3:  MOVLB  01
04D4:  MOVWF  31
04D5:  MOVLB  00
04D6:  CALL   1C6
04D7:  MOVLW  32
04D8:  MOVLB  01
04D9:  MOVWF  31
04DA:  MOVLB  00
04DB:  CALL   1C6
04DC:  MOVLW  20
04DD:  MOVLB  01
04DE:  MOVWF  31
04DF:  MOVLB  00
04E0:  CALL   1C6
....................           delay_ms(100);  
04E1:  MOVLW  64
04E2:  MOVLB  01
04E3:  MOVWF  32
04E4:  MOVLB  00
04E5:  CALL   050
....................     lcd_putc("\f" ) ; 
04E6:  MOVLW  4D
04E7:  MOVLB  03
04E8:  MOVWF  11
04E9:  MOVLW  00
04EA:  MOVWF  12
04EB:  MOVLB  00
04EC:  CALL   200
....................        
....................     
....................      
....................      
....................         output_high (PIN_B3); 
04ED:  MOVLB  01
04EE:  BCF    0D.3
04EF:  MOVLB  02
04F0:  BSF    0D.3
....................      delay_ms(5);   
04F1:  MOVLW  05
04F2:  MOVLB  01
04F3:  MOVWF  32
04F4:  MOVLB  00
04F5:  CALL   050
....................         output_low (PIN_B3); 
04F6:  MOVLB  01
04F7:  BCF    0D.3
04F8:  MOVLB  02
04F9:  BCF    0D.3
....................          delay_ms(5);  
04FA:  MOVLW  05
04FB:  MOVLB  01
04FC:  MOVWF  32
04FD:  MOVLB  00
04FE:  CALL   050
....................     lcd_gotoxy(8,1); 
04FF:  MOVLW  08
0500:  MOVLB  01
0501:  MOVWF  32
0502:  MOVLW  01
0503:  MOVWF  33
0504:  MOVLB  00
0505:  CALL   1B2
....................          printf(lcd_putc," 1 "); 
0506:  MOVLW  20
0507:  MOVLB  01
0508:  MOVWF  31
0509:  MOVLB  00
050A:  CALL   1C6
050B:  MOVLW  31
050C:  MOVLB  01
050D:  MOVWF  31
050E:  MOVLB  00
050F:  CALL   1C6
0510:  MOVLW  20
0511:  MOVLB  01
0512:  MOVWF  31
0513:  MOVLB  00
0514:  CALL   1C6
....................           delay_ms(100);  
0515:  MOVLW  64
0516:  MOVLB  01
0517:  MOVWF  32
0518:  MOVLB  00
0519:  CALL   050
....................     lcd_putc("\f" ) ; 
051A:  MOVLW  4E
051B:  MOVLB  03
051C:  MOVWF  11
051D:  MOVLW  00
051E:  MOVWF  12
051F:  MOVLB  00
0520:  CALL   200
....................      
....................    output_high (PIN_B3); 
0521:  MOVLB  01
0522:  BCF    0D.3
0523:  MOVLB  02
0524:  BSF    0D.3
....................      delay_ms(50);   
0525:  MOVLW  32
0526:  MOVLB  01
0527:  MOVWF  32
0528:  MOVLB  00
0529:  CALL   050
....................         output_low (PIN_B3); 
052A:  MOVLB  01
052B:  BCF    0D.3
052C:  MOVLB  02
052D:  BCF    0D.3
....................          delay_ms(50); 
052E:  MOVLW  32
052F:  MOVLB  01
0530:  MOVWF  32
0531:  MOVLB  00
0532:  CALL   050
....................        
....................  
.................... while(TRUE){//ciclo infinito 
....................      
.................... principal (); //llamamos a la funcin principal 
0533:  MOVLP  08
0534:  GOTO   000
0535:  MOVLP  00
0536:  GOTO   533
....................  
....................  
....................          
.................... }    
....................      
....................      
....................      
....................      
....................      
....................    delay_ms(100);    
0537:  MOVLW  64
0538:  MOVLB  01
0539:  MOVWF  32
053A:  MOVLB  00
053B:  CALL   050
....................    lcd_putc("\f" ) ; //limpia la pantalla 
053C:  MOVLW  4F
053D:  MOVLB  03
053E:  MOVWF  11
053F:  MOVLW  00
0540:  MOVWF  12
0541:  MOVLB  00
0542:  CALL   200
....................        
.................... } 
.................... /* 
0543:  SLEEP
....................  Final del proyecto Final 
....................   */ 

Configuration Fuses:
   Word  1: 3FE1   XT NOWDT NOPUT MCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1FFF   NOWRT NOVCAP PLL STVREN BORV19 NODEBUG NOLVP
